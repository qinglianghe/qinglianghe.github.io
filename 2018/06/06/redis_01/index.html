<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Redis是一种基于键值对（key-value）的NoSQL数据库，它支持string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis基本操作">
<meta property="og:url" content="http://yoursite.com/2018/06/06/redis_01/index.html">
<meta property="og:site_name" content="heqingliang&#39;s Blog">
<meta property="og:description" content="Redis是一种基于键值对（key-value）的NoSQL数据库，它支持string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/redis/object_encoding.png">
<meta property="og:image" content="http://yoursite.com/images/redis/redis_cache.png">
<meta property="og:updated_time" content="2018-06-19T23:10:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis基本操作">
<meta name="twitter:description" content="Redis是一种基于键值对（key-value）的NoSQL数据库，它支持string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法。">
<meta name="twitter:image" content="http://yoursite.com/images/redis/object_encoding.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/06/redis_01/"/>





  <title>Redis基本操作 | heqingliang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">heqingliang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/redis_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="heqingliang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dva.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="heqingliang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis基本操作</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T00:00:00+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p><code>Redis</code>是一种基于键值对（key-value）的NoSQL数据库，它支持<code>string</code>（字符串）、<code>hash</code>（哈希）、<code>list</code>（列表）、<code>set</code>（集合）、<code>zset</code>（有序集合）、<code>Bitmaps</code>（位图）、<code>HyperLogLog</code>、<code>GEO</code>（地理信息定位）等多种数据结构和算法。<a id="more"></a>因为Redis会将所有数据都存放在内存中，所以它的读写性能非常惊人。不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。除了上述功能以外，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</p>
<h3 id="安装并启动Redis"><a href="#安装并启动Redis" class="headerlink" title="安装并启动Redis"></a>安装并启动Redis</h3><h4 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h4><pre><code>wget http://download.redis.io/releases/redis-3.0.7.tar.gz
tar xzf redis-3.0.7.tar.gz
cd redis-3.0.7/
make
sudo make install
</code></pre><p><code>Redis</code>安装之后，src和<code>/usr/local/bin</code>目录下多了几个以<code>redis</code>开头可执行文件，我们称之为<code>Redis Shell</code>，这些可执行文件可以做很多事情，例如可以启动和停止Redis、可以检测和修复<code>Redis</code>的持久化文件，还可以检测<code>Redis</code>的性能。</p>
<table>
<thead>
<tr>
<th>可执行文件</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>redis-server</td>
<td style="text-align:left">启动 Redis</td>
</tr>
<tr>
<td>redis-cli</td>
<td style="text-align:left">Redis 命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td style="text-align:left">Redis 基准测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td style="text-align:left">Redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td style="text-align:left">Redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td style="text-align:left">启动 Redis Sentinel</td>
</tr>
</tbody>
</table>
<h4 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h4><p>有三种方法启动Redis：默认配置、运行配置、配置文件启动。</p>
<ol>
<li>默认配置</li>
</ol>
<p>这种方法会使用<code>Redis</code>的默认配置来启动。</p>
<pre><code>redis-server
</code></pre><p>因为直接启动无法自定义配置，所以这种方式是不会在生产环境中使用的。</p>
<ol>
<li>运行启动</li>
</ol>
<p><code>redis-server</code>加上要修改配置名和值（可以是多对），没有设置的配置将使用默认配置：</p>
<pre><code>redis-server --configKey1 configValue1 --configKey2 configValue2
</code></pre><p>如果要用6380作为端口启动<code>Redis</code>，那么可以执行：</p>
<pre><code>redis-server --port 6380
</code></pre><p>因为直接启动无法自定义配置，所以这种方式是不会在生产环境中使用的。</p>
<ol>
<li>配置文件启动</li>
</ol>
<p>将配置写到指定文件里，例如将配置写到了<code>/opt/redis/redis.conf</code>中，那么只需要执行如下命令即可启动<code>Redis</code>：</p>
<pre><code>redis-server /opt/redis/redis.conf
</code></pre><p>通过配置文件启动的方式提供了更大的灵活性，所以大部分生产环境会使用这种方式启动<code>Redis</code>。</p>
<h4 id="Redis命令行客户端"><a href="#Redis命令行客户端" class="headerlink" title="Redis命令行客户端"></a>Redis命令行客户端</h4><p>第一种是交互式方式：通过<code>redis-cli-h{host}-p{port}</code>的方式连接到<code>Redis</code>服务：</p>
<pre><code>[heql@ubuntu ~]$ redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; get hello
&quot;world&quot;
</code></pre><p>第二种是命令方式：用<code>redis-cli-h ip{host}-p{port}{command}</code>就可以直接得到命令的返回结果：</p>
<pre><code>[heql@ubuntu ~]$ redis-cli -h 127.0.0.1 -p 6379 get hello 
&quot;world&quot;
</code></pre><p>如果没有<code>-h</code>参数，那么默认连接<code>127.0.0.1</code>；如<br>果没有<code>-p</code>，那么默认<code>6379</code>端口，也就是说如果<code>-h</code>和<code>-p</code>都没写就是连接<code>127.0.0.1：6379</code>这个<code>Redis</code>实例。</p>
<h4 id="停止Redis服务"><a href="#停止Redis服务" class="headerlink" title="停止Redis服务"></a>停止Redis服务</h4><pre><code>redis-cli -h 127.0.0.1 -p 6379 shutdown
</code></pre><p><strong>注意：</strong></p>
<ol>
<li><p>通过<code>shutdown</code>命令关闭<code>Redis</code>服务: 断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</p>
</li>
<li><p>通过<code>kill</code>进程号的方式关闭掉<code>Redis</code>: 不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况会造成<code>AOF</code>和复制丢失数据的情况。</p>
</li>
<li><p><code>shutdown</code>还有一个参数，代表是否在关闭<code>Redis</code>前，生成持久化文件：</p>
<pre><code>redis-cli shutdown nosave|save
</code></pre></li>
</ol>
<h3 id="API的理解和使用"><a href="#API的理解和使用" class="headerlink" title="API的理解和使用"></a>API的理解和使用</h3><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><p><code>Redis</code>有5种数据结构，它们是键值对中的值，对于键来说有一些通用的命令。</p>
<h5 id="查看所有键-key"><a href="#查看所有键-key" class="headerlink" title="查看所有键(key*)"></a>查看所有键(key*)</h5><p>下面插入了3对字符串类型的键值对：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; set java jedis
OK
127.0.0.1:6379&gt; set python redis-py
OK
</code></pre><p>keys*命令会将所有的键输出：</p>
<pre><code>127.0.0.1:6379&gt; keys *
1) &quot;hello&quot;
2) &quot;python&quot;
3) &quot;java&quot;
</code></pre><h5 id="键总数-dbsize"><a href="#键总数-dbsize" class="headerlink" title="键总数(dbsize)"></a>键总数(dbsize)</h5><p>下面插入一个列表类型的键值对（值是多个元素组成）：</p>
<pre><code>127.0.0.1:6379&gt; rpush mylist a b c d e f g
(integer) 7
</code></pre><p><code>dbsize</code>命令会返回当前数据库中键的总数。例如当前数据库有4个键，分别是hello、java、python、mylist，所以<code>dbsize</code>的结果是4：</p>
<pre><code>127.0.0.1:6379&gt; dbsize
(integer) 4
</code></pre><p><code>dbsize</code>命令在计算键总数时不会遍历所有键，而是直接获取<code>Redis</code>内置的键总数变量，所以<code>dbsize</code>命令的时间复杂度是O（1）。而<code>keys</code>命令会遍历所有键，所以它的时间复杂度是O（n），当<code>Redis</code>保存了大量键时，线上环境禁止使用。</p>
<h5 id="检查键是否存在-exists"><a href="#检查键是否存在-exists" class="headerlink" title="检查键是否存在(exists)"></a>检查键是否存在(exists)</h5><p>如果键存在则返回1，不存在则返回0：</p>
<pre><code>127.0.0.1:6379&gt; exists java
(integer) 1
127.0.0.1:6379&gt; exists no_exist_key
(integer) 0
</code></pre><h5 id="删除键-del"><a href="#删除键-del" class="headerlink" title="删除键(del)"></a>删除键(del)</h5><p><code>del</code>是一个通用命令，无论值是什么数据结构类型，<code>del</code>命令都可以将其删除，返回结果为成功删除键的个数，假设删除一个不存在的键，就会返回<br>0:</p>
<pre><code>127.0.0.1:6379&gt; del java
(integer) 1
127.0.0.1:6379&gt; exists java
(integer) 0
127.0.0.1:6379&gt; del mylist 
(integer) 1
127.0.0.1:6379&gt; exists mylist
(integer) 0
127.0.0.1:6379&gt; del no_exist_key
(integer) 0
</code></pre><p><code>del</code>命令可以支持删除多个键：</p>
<pre><code>127.0.0.1:6379&gt; set a 1
OK
127.0.0.1:6379&gt; set b 2
OK
127.0.0.1:6379&gt; set c 3
OK
127.0.0.1:6379&gt; del a b c 
(integer) 3
</code></pre><h5 id="键过期-expire"><a href="#键过期-expire" class="headerlink" title="键过期(expire)"></a>键过期(expire)</h5><p><code>Redis</code>支持对键添加过期时间，当超过过期时间后，会自动删除键，例如为键hello设置了10秒过期时间：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; expire hello 10
(integer) 1
</code></pre><p><code>ttl</code>命令会返回键的剩余过期时间，它有3种返回值：</p>
<ul>
<li>大于等于0的整数：键剩余的过期时间。</li>
<li>-1：键没设置过期时间。</li>
<li>键不存在</li>
</ul>
<p>通过<code>ttl</code>命令观察键hello的剩余过期时间:</p>
<pre><code>127.0.0.1:6379&gt; ttl hello
(integer) 8
127.0.0.1:6379&gt; ttl hello
(integer) -2
127.0.0.1:6379&gt; get hello
(nil)
</code></pre><h5 id="键的数据结构类型-type"><a href="#键的数据结构类型-type" class="headerlink" title="键的数据结构类型(type)"></a>键的数据结构类型(type)</h5><pre><code>127.0.0.1:6379&gt; type a
string
127.0.0.1:6379&gt; rpush mylist a b c d
(integer) 4
127.0.0.1:6379&gt; type mylist
list
</code></pre><p>如果键不存在，则返回<code>none</code>：</p>
<pre><code>127.0.0.1:6379&gt; type no_exist_key
none
</code></pre><h4 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h4><p><code>type</code>命令实际返回的就是当前键的数据结构类型，它们分别是：<code>string</code>（字符串）、<code>hash</code>（哈希）、<code>list</code>（列表）、<code>set</code>（集合）、<code>zset</code>（有序集合），但这些只是Redis对外的数据结构。</p>
<p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样<code>Redis</code>会在合适的场景选择合适的内部编码，如图:</p>
<p><img src="/images/redis/object_encoding.png" alt="object_encoding.png"></p>
<p>可以看到每种数据结构都有两种以上的内部编码实现，例如<code>list</code>数据结构包含了<code>linkedlist</code>和<code>ziplist</code>两种内部编码。同时有些内部编码，例<code>ziplist</code>，可以作为多种外部数据结构的内部实现，可以通过<code>object encoding</code>命令查询内部编码：</p>
<pre><code>127.0.0.1:6379&gt; object encoding python
&quot;embstr&quot;
127.0.0.1:6379&gt; object encoding mylist
&quot;ziplist&quot;
</code></pre><p><code>Redis</code>这样设计有两个好处：</p>
<ul>
<li>可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令。</li>
<li>多种内部编码实现可以在不同场景下发挥各自的优势，例如<code>ziplist</code>比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候<code>Redis</code>会根据配置选项将列表类型的内部实现转换为<code>linkedlist</code>。</li>
</ul>
<h4 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h4><p><code>Redis</code>使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。</p>
<p>现在开启了三个<code>redis-cli</code>客户端同时执行命令:</p>
<p>客户端1设置一个字符串键值对：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
</code></pre><p>客户端2对counter做自增操作：</p>
<pre><code>127.0.0.1:6379&gt; incr counter
</code></pre><p>客户端3对counter做自增操作：</p>
<pre><code>127.0.0.1:6379&gt; incr counter
</code></pre><p>因为<code>Redis</code>是单线程来处理命令的，所以一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。所以上面3个客户端命令的执行顺序是不确定的，但是可以确定不会有两条命令被同时执行，所以两条<code>incr</code>命令无论怎么执行最终结果都是2，不会产生并发问题，这就是<code>Redis</code>单线程的基本模型。</p>
<h5 id="为什么单线程还能这么快"><a href="#为什么单线程还能这么快" class="headerlink" title="为什么单线程还能这么快"></a>为什么单线程还能这么快</h5><ul>
<li>纯内存访问，<code>Redis</code>将所有数据放在内存中，内存的响应时长大约为100纳秒，这是<code>Redis</code>达到每秒万级别访问的重要基础。</li>
<li>非阻塞I/O，<code>Redis</code>使用<code>epoll</code>作为I/O多路复用技术的实现，再加上<code>Redis</code>自身的事件处理模型将<code>epoll</code>中的连接、读写、关闭都转换为事件，不<br>在网络I/O上浪费过多的时间。</li>
<li>单线程避免了线程切换和竞态产生的消耗。</li>
</ul>
<p>但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于<code>Redis</code>这种高性能的服务来说是致命的，所以<code>Redis</code>是面向快速执行场景的数据库。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如JSON、XML））、数字（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过512MB。</p>
<h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><h6 id="设置值-set"><a href="#设置值-set" class="headerlink" title="设置值(set)"></a>设置值(set)</h6><p>set key value [ex seconds] [px milliseconds] [nx|xx]</p>
<ul>
<li>ex seconds：为键设置秒级过期时间。</li>
<li>px milliseconds：为键设置毫秒级过期时间。</li>
<li>nx：键必须不存在，才可以设置成功，用于添加。</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新</li>
</ul>
<p>返回结果为OK代表设置成功：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
</code></pre><p>除了<code>set</code>选项，<code>Redis</code>还提供了<code>setex</code>和<code>setnx</code>两个命令，它们的作用和<code>ex</code>和<code>nx</code>选项是一样的。</p>
<p>因为键hello已存在，所以<code>setnx</code>失败，返回结果为0：</p>
<pre><code>127.0.0.1:6379&gt; exists hello
(integer) 1
127.0.0.1:6379&gt; setnx hello redis
(integer) 0
</code></pre><p><code>setnx</code>和<code>setxx</code>在实际使用中有什么应用场景吗？以<code>setnx</code>命令为例子，由于<code>Redis</code>的单线程命令处理机制，如果有多个客户端同时执行<code>setnx key value</code>，根据<code>setnx</code>的特性只有一个客户端能设置成功，<code>setnx</code>可以作为分布式锁的一种实现方案。</p>
<h6 id="获取值-get"><a href="#获取值-get" class="headerlink" title="获取值(get)"></a>获取值(get)</h6><p>如果要获取的键不存在，则返回nil（空）：</p>
<pre><code>127.0.0.1:6379&gt; get hello
&quot;world&quot;
127.0.0.1:6379&gt; get not_exist_key
(nil)
</code></pre><h6 id="批量设置值-mset"><a href="#批量设置值-mset" class="headerlink" title="批量设置值(mset)"></a>批量设置值(mset)</h6><p>下面操作通过<code>mset</code>命令一次性设置4个键值对：</p>
<pre><code>127.0.0.1:6379&gt; mset a 1 b 2 c 3 d 4
OK
</code></pre><h6 id="批量获取值-mget"><a href="#批量获取值-mget" class="headerlink" title="批量获取值(mget)"></a>批量获取值(mget)</h6><p>下面操作批量获取了键a、b、c、d的值：</p>
<pre><code>127.0.0.1:6379&gt; mget a b c d
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
</code></pre><p>如果有些键不存在，那么它的值为nil（空）：</p>
<pre><code>127.0.0.1:6379&gt; mget a b f d
1) &quot;1&quot;
2) &quot;2&quot;
3) (nil)
4) &quot;4&quot;
</code></pre><p>批量操作命令可以有效提高开发效率，假如没有<code>mget</code>这样的命令，要执行n次get命令:</p>
<pre><code>n次get时间 = n次网络时间 + n次命令时间
</code></pre><h6 id="计数-incr"><a href="#计数-incr" class="headerlink" title="计数(incr)"></a>计数(incr)</h6><p><code>incr</code>命令用于对值做自增操作，返回结果分为三种情况：</p>
<ul>
<li>值不是整数，返回错误。</li>
<li>值是整数，返回自增后的结果。</li>
<li><p>键不存在，按照值为0自增，返回结果为1。</p>
<pre><code>127.0.0.1:6379&gt; exists key
(integer) 0
127.0.0.1:6379&gt; incr key
(integer) 1
127.0.0.1:6379&gt; incr key
(integer) 2
127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; incr hello
(error) ERR value is not an integer or out of range
</code></pre></li>
</ul>
<p>除了<code>incr</code>命令，<code>Redis</code>提供了<code>decr</code>（自减）、<code>incrby</code>（自增指定数字）、<code>decrby</code>（自减指定数字）、<code>incrbyfloat</code>（自增浮点数）：</p>
<pre><code>decr key
incrby key increment
decrby key decrement
incrbyfloat key increment
</code></pre><h5 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h5><h6 id="追加值-append"><a href="#追加值-append" class="headerlink" title="追加值(append)"></a>追加值(append)</h6><p><code>append</code>可以向字符串尾部追加值:</p>
<pre><code>127.0.0.1:6379&gt; get hello
&quot;world&quot;
127.0.0.1:6379&gt; append hello redis
(integer) 10
127.0.0.1:6379&gt; get hello
&quot;worldredis&quot;
</code></pre><h6 id="字符串长度-strlen"><a href="#字符串长度-strlen" class="headerlink" title="字符串长度(strlen)"></a>字符串长度(strlen)</h6><p>当前值为worldredis，所以返回值为10：</p>
<pre><code>127.0.0.1:6379&gt; get hello 
&quot;worldredis&quot;
127.0.0.1:6379&gt; strlen hello
(integer) 10
</code></pre><h6 id="设置并返回原值-getset"><a href="#设置并返回原值-getset" class="headerlink" title="设置并返回原值(getset)"></a>设置并返回原值(getset)</h6><p><code>getset</code>和<code>set</code>一样会设置值，但是不同的是，它同时会返回键原来的值:</p>
<pre><code>127.0.0.1:6379&gt; getset hello world
&quot;worldredis&quot;
127.0.0.1:6379&gt; getset hello redis
&quot;world&quot;
127.0.0.1:6379&gt; get hello
&quot;redis&quot;
</code></pre><h6 id="设置指定位置的字符-setrange"><a href="#设置指定位置的字符-setrange" class="headerlink" title="设置指定位置的字符(setrange)"></a>设置指定位置的字符(setrange)</h6><p>下面操作将值由pest变为了best</p>
<pre><code>127.0.0.1:6379&gt; set redis pest
OK
127.0.0.1:6379&gt; setrange redis 0 b
(integer) 4
127.0.0.1:6379&gt; get redis
&quot;best&quot;
</code></pre><h6 id="获取部分字符串-getrange"><a href="#获取部分字符串-getrange" class="headerlink" title="获取部分字符串(getrange)"></a>获取部分字符串(getrange)</h6><p>getrange key start end</p>
<p>start和end分别是开始和结束的偏移量</p>
<pre><code>127.0.0.1:6379&gt; getrange redis 0 1
&quot;be&quot;
</code></pre><h5 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h5><p>字符串类型的内部编码有3种：</p>
<ul>
<li>int：8个字节的长整型。</li>
<li>embstr：小于等于39个字节的字符串。</li>
<li>raw：大于39个字节的字符串。</li>
</ul>
<p><code>Redis</code>会根据当前值的类型和长度决定使用哪种内部编码实现:</p>
<pre><code>127.0.0.1:6379&gt; set key 123
OK
127.0.0.1:6379&gt; object encoding key
&quot;int&quot;
127.0.0.1:6379&gt; set key &quot;hello world&quot;
OK
127.0.0.1:6379&gt; object encoding key
&quot;embstr&quot;
</code></pre><h5 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h5><h6 id="缓存功能"><a href="#缓存功能" class="headerlink" title="缓存功能"></a>缓存功能</h6><p>下图是比较典型的缓存使用场景，其中<code>Redis</code>作为缓存层，<code>MySQL</code>作为存储层，绝大部分请求的数据都是从<code>Redis</code>中获取。由于<code>Redis</code>具有支撑高并发的特性，所以缓存通常能起到加速读写和降低后端压力的作用。</p>
<p><img src="/images/redis/redis_cache.png" alt="redis_cache.png"></p>
<h6 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h6><p>许多应用都会使用<code>Redis</code>作为计数的基础工具，它可以实现快速计数、查询缓存的功能，同时数据可以异步落地到其他数据源。如：视频的播放次数。</p>
<h6 id="共享Session"><a href="#共享Session" class="headerlink" title="共享Session"></a>共享Session</h6><p>可以使用<code>Redis</code>将用户的Session进行集中管理，在这种模式下只要保证Redis是高可用和扩展性的，每次用户更新或者查询登录信息都直接从<code>Redis中</code>集中获取。</p>
<h6 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h6><p>很多应用出于安全的考虑，会在每次进行登录时，让用户输入手机验证码，从而确定是否是用户本人。但是为了短信接口不被频繁访问，会限制用户每分钟获取验证码的频率，例如一分钟不能超过5次。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>在<code>Redis</code>中，哈希类型是指键值本身又是一个键值对结构。</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h5 id="设置值-hset"><a href="#设置值-hset" class="headerlink" title="设置值(hset)"></a>设置值(hset)</h5><p>设置成功会返回1，反之会返回0。此外<code>Redis</code>提供了<code>hsetnx</code>命令，它们的关系就像<code>set</code>和<code>setnx</code>命令一样，只不过作用域由键变为<code>field</code>。</p>
<pre><code>127.0.0.1:6379&gt; hset user:1 name tom
(integer) 1
</code></pre><h5 id="获取值-hget"><a href="#获取值-hget" class="headerlink" title="获取值(hget)"></a>获取值(hget)</h5><p>如果键或field不存在，会返回nil：</p>
<pre><code>127.0.0.1:6379&gt; hget user:1 name
&quot;tom&quot;
127.0.0.1:6379&gt; hget user:2 name
(nil)
127.0.0.1:6379&gt; hget user:1 age
(nil)
</code></pre><h5 id="删除field-hdel"><a href="#删除field-hdel" class="headerlink" title="删除field(hdel)"></a>删除field(hdel)</h5><p><code>hdel</code>会删除一个或多个field，返回结果为成功删除field的个数：</p>
<pre><code>127.0.0.1:6379&gt; hdel user:1 name
(integer) 1
127.0.0.1:6379&gt; hdel user:1 age
(integer) 0
</code></pre><h5 id="计算field个数-hlen"><a href="#计算field个数-hlen" class="headerlink" title="计算field个数(hlen)"></a>计算field个数(hlen)</h5><pre><code>127.0.0.1:6379&gt; hset user:1 name tom
(integer) 0
127.0.0.1:6379&gt; hset user:1 age 23
(integer) 1
127.0.0.1:6379&gt; hset user:1 city guangzhou
(integer) 1
127.0.0.1:6379&gt; hlen user:1
(integer) 3
</code></pre><h5 id="批量设置或获取field-value-hmget、hmset"><a href="#批量设置或获取field-value-hmget、hmset" class="headerlink" title="批量设置或获取field-value(hmget、hmset)"></a>批量设置或获取field-value(hmget、hmset)</h5><p><code>hmset</code>和<code>hmget</code>分别是批量设置和获取field-value，<code>hmset</code>需要的参数是key和多对field-value，<code>hmget</code>需要的参数是key和多个field:</p>
<pre><code>127.0.0.1:6379&gt; hmset user:1 name mike age 12 city guangzhou
OK
127.0.0.1:6379&gt; hmget user:1 name city
1) &quot;mike&quot;
2) &quot;guangzhou&quot;
</code></pre><h5 id="判断field是否存在-hexists"><a href="#判断field是否存在-hexists" class="headerlink" title="判断field是否存在(hexists)"></a>判断field是否存在(hexists)</h5><pre><code>127.0.0.1:6379&gt; hexists user:1 name 
(integer) 1
127.0.0.1:6379&gt; hexists user:1 no_exist_field
(integer) 0
</code></pre><h5 id="获取所有field-hkeys"><a href="#获取所有field-hkeys" class="headerlink" title="获取所有field(hkeys)"></a>获取所有field(hkeys)</h5><p><code>hkeys</code>返回指定哈希键所有的field:</p>
<pre><code>127.0.0.1:6379&gt; hkeys user:1
1) &quot;name&quot;
2) &quot;age&quot;
3) &quot;city&quot;
</code></pre><h5 id="获取所有value-hvals"><a href="#获取所有value-hvals" class="headerlink" title="获取所有value(hvals)"></a>获取所有value(hvals)</h5><pre><code>127.0.0.1:6379&gt; hvals user:1
1) &quot;mike&quot;
2) &quot;12&quot;
3) &quot;guangzhou&quot;
</code></pre><h5 id="获取所有的field-value-hgetall"><a href="#获取所有的field-value-hgetall" class="headerlink" title="获取所有的field-value(hgetall)"></a>获取所有的field-value(hgetall)</h5><pre><code>127.0.0.1:6379&gt; hgetall user:1
1) &quot;name&quot;
2) &quot;mike&quot;
3) &quot;age&quot;
4) &quot;12&quot;
5) &quot;city&quot;
6) &quot;guangzhou&quot;
</code></pre><p>在使用<code>hgetall</code>时，如果哈希元素个数比较多，会存在阻塞<code>Redis</code>的可能。如果开发人员只需要获取部分field，可以使用<code>hmget</code>，如果一定要获取全部field-value，可以使用<code>hscan</code>命令，该命令会渐进式遍历哈希类型。</p>
<h5 id="hincrby-hincrbyfloat"><a href="#hincrby-hincrbyfloat" class="headerlink" title="hincrby hincrbyfloat"></a>hincrby hincrbyfloat</h5><p><code>hincrby</code>和<code>hincrbyfloat</code>，就像<code>incrby</code>和<code>incrbyfloat</code>命令一样，但是它们的作用域是filed。</p>
<h4 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h4><p>哈希类型的内部编码有两种：</p>
<ul>
<li><code>ziplist</code>（压缩列表）：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置（默认512个）、同时所有值都小于<code>hash-max-ziplist-value</code>配置（默认64字节）时，<code>Redis</code>会使用<code>ziplist</code>作为哈希的内部实现，<code>ziplist</code>使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li>
<li><code>hashtable</code>（哈希表）：当哈希类型无法满足<code>ziplist</code>的条件时，<code>Redis</code>会使用<code>hashtable</code>作为哈希的内部实现，因为此时ziplist的读写效率会下降，而<code>hashtable</code>的读写时间复杂度为O（1）。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素（element），一个列表最多可以存储2^32-1个元素。在<code>Redis</code>中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。</p>
<p>列表类型有两个特点：</p>
<ul>
<li>列表中的元素是有序的，这就意味着可以通过索引下标获取某个元素或者某个范围内的元素列表。</li>
<li>列表中的元素可以是重复的。</li>
</ul>
<h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><h5 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h5><h6 id="从右边插入元素-rpush"><a href="#从右边插入元素-rpush" class="headerlink" title="从右边插入元素(rpush)"></a>从右边插入元素(rpush)</h6><pre><code>127.0.0.1:6379&gt; rpush listkey c b a
(integer) 3
</code></pre><h6 id="从左边插入元素-lpush"><a href="#从左边插入元素-lpush" class="headerlink" title="从左边插入元素(lpush)"></a>从左边插入元素(lpush)</h6><p>使用方法和<code>rpush</code>相同。</p>
<h6 id="向某个元素前或者后插入元素-linsert"><a href="#向某个元素前或者后插入元素-linsert" class="headerlink" title="向某个元素前或者后插入元素(linsert)"></a>向某个元素前或者后插入元素(linsert)</h6><p>linsert key before|after pivot value</p>
<p><code>linsert</code>命令会从列表中找到等于pivot的元素，在其前（before）或者后（after）插入一个新的元素value，返回结果，代表当前的长度：</p>
<pre><code>127.0.0.1:6379&gt; linsert listkey before b java
(integer) 4
127.0.0.1:6379&gt; lrange listkey 0 -1
1) &quot;c&quot;
2) &quot;java&quot;
3) &quot;b&quot;
4) &quot;a&quot;
</code></pre><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><h6 id="获取指定范围内的元素列表-lrange"><a href="#获取指定范围内的元素列表-lrange" class="headerlink" title="获取指定范围内的元素列表(lrange):"></a>获取指定范围内的元素列表(lrange):</h6><p> lrange key start end</p>
<p><code>lrange</code>操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>
<ul>
<li>索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N</li>
<li><code>lrange</code>中的end选项包含了自身</li>
</ul>
<p>获取列表的第2到第4个元素：</p>
<pre><code>127.0.0.1:6379&gt; lrange listkey 1 3
1) &quot;java&quot;
2) &quot;b&quot;
3) &quot;a&quot;
</code></pre><h6 id="获取列表指定索引下标的元素-lindex-："><a href="#获取列表指定索引下标的元素-lindex-：" class="headerlink" title="获取列表指定索引下标的元素(lindex)："></a>获取列表指定索引下标的元素(lindex)：</h6><pre><code>127.0.0.1:6379&gt; lindex listkey -1
&quot;a&quot;
</code></pre><h6 id="获取列表长度-llen-："><a href="#获取列表长度-llen-：" class="headerlink" title="获取列表长度(llen)："></a>获取列表长度(llen)：</h6><pre><code>127.0.0.1:6379&gt; llen listkey
(integer) 4
</code></pre><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><h6 id="从列表左侧弹出元素-lpop"><a href="#从列表左侧弹出元素-lpop" class="headerlink" title="从列表左侧弹出元素(lpop)"></a>从列表左侧弹出元素(lpop)</h6><p>如下操作将列表最左侧的元素c会被弹出:</p>
<pre><code>127.0.0.1:6379&gt; lpop listkey
&quot;c&quot;
127.0.0.1:6379&gt; lrange listkey 0 -1
1) &quot;java&quot;
2) &quot;b&quot;
3) &quot;a&quot;
</code></pre><h6 id="从列表右侧弹出-rpop"><a href="#从列表右侧弹出-rpop" class="headerlink" title="从列表右侧弹出(rpop)"></a>从列表右侧弹出(rpop)</h6><p>使用方法和<code>lpop</code>一样。</p>
<h6 id="删除指定元素-lrem"><a href="#删除指定元素-lrem" class="headerlink" title="删除指定元素(lrem)"></a>删除指定元素(lrem)</h6><p>lrem key count value</p>
<p><code>lrem</code>命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况： </p>
<ul>
<li>count&gt;0，从左到右，删除最多count个元素。</li>
<li>count&lt;0，从右到左，删除最多count绝对值个元素。</li>
<li>count=0，删除所有。</li>
</ul>
<p>当前列表为“a a a a a java b a”，下面操作将从列表左边开始删除4个为a的元素：</p>
<pre><code>127.0.0.1:6379&gt; lrem listkey 4 a
(integer) 4
127.0.0.1:6379&gt; lrange listkey 0 -1
1) &quot;a&quot;
2) &quot;java&quot;
3) &quot;b&quot;
4) &quot;a&quot;
</code></pre><h6 id="按照索引范围修剪列表-ltrim"><a href="#按照索引范围修剪列表-ltrim" class="headerlink" title="按照索引范围修剪列表(ltrim)"></a>按照索引范围修剪列表(ltrim)</h6><p>ltrim key start end</p>
<p>下面操作会只保留列表listkey第2个到第4个元素：</p>
<pre><code>127.0.0.1:6379&gt; ltrim listkey 1 3
OK
127.0.0.1:6379&gt; lrange listkey 0 -1
1) &quot;java&quot;
2) &quot;b&quot;
3) &quot;a&quot;
</code></pre><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>修改指定索引下标的元素(lset)：</p>
<p>lset key index newValue</p>
<pre><code>127.0.0.1:6379&gt; lset listkey 2 python
OK
127.0.0.1:6379&gt; lrange listkey 0 -1
1) &quot;java&quot;
2) &quot;b&quot;
3) &quot;python&quot;
</code></pre><h5 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h5><p>blpop key [key …] timeout<br>brpop key [key …] timeout</p>
<p><code>blpop</code>和<code>brpop</code>是<code>lpop</code>和<code>rpop</code>的阻塞版本:</p>
<ul>
<li>key[key…]：多个列表的键。</li>
<li>timeout：阻塞时间（单位：秒）。timeout=0，那么客户端一直阻塞等下去。    </li>
</ul>
<h4 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h4><p>列表类型的内部编码有两种:</p>
<ul>
<li><code>ziplist</code>（压缩列表）：当列表的元素个数小于<code>list-max-ziplist-entries</code>配置（默认512个），同时列表中每个元素的值都小于<code>list-max-ziplist-value</code>配置时（默认64字节），<code>Redis</code>会选用<code>ziplist</code>来作为列表的内部实现来减少内存的使用。</li>
<li><code>linkedlist</code>（链表）：当列表类型无法满足<code>ziplist</code>的条件时，<code>Redis</code>会使用<code>linkedlist</code>作为列表的内部实现。</li>
</ul>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h5><p><code>Redis</code>的<code>lpush+brpop</code>命令组合即可实现阻塞队列，生产者客户端使用<code>lrpush</code>从列表左侧插入元素，多个消费者客户端使用<code>brpop</code>命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用<br>性。</p>
<h5 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h5><p>每个用户有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储232-1个元素。<code>Redis</code>除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><h5 id="集合内操作"><a href="#集合内操作" class="headerlink" title="集合内操作"></a>集合内操作</h5><h6 id="添加元素-sadd"><a href="#添加元素-sadd" class="headerlink" title="添加元素(sadd)"></a>添加元素(sadd)</h6><p>返回结果为添加成功的元素个数：</p>
<pre><code>127.0.0.1:6379&gt; exists myset
(integer) 0
127.0.0.1:6379&gt; sadd myset a b c
(integer) 3
127.0.0.1:6379&gt; sadd myset a b
(integer) 0
</code></pre><h6 id="删除元素-srem"><a href="#删除元素-srem" class="headerlink" title="删除元素(srem)"></a>删除元素(srem)</h6><p>返回结果为成功删除元素个数：</p>
<pre><code>127.0.0.1:6379&gt; srem myset a b
(integer) 2
127.0.0.1:6379&gt; srem myset hello
(integer) 0
</code></pre><h6 id="计算元素个数-scard"><a href="#计算元素个数-scard" class="headerlink" title="计算元素个数(scard)"></a>计算元素个数(scard)</h6><p><code>scard</code>的时间复杂度为O（1），它不会遍历集合所有元素，而是直接用<code>Redis</code>内部的变量：</p>
<pre><code>127.0.0.1:6379&gt; scard myset
(integer) 1
</code></pre><h6 id="判断元素是否在集合中-sismember"><a href="#判断元素是否在集合中-sismember" class="headerlink" title="判断元素是否在集合中(sismember)"></a>判断元素是否在集合中(sismember)</h6><p>如果给定元素在集合内返回1，反之返回0:</p>
<pre><code>127.0.0.1:6379&gt; sismember myset c
(integer) 1
</code></pre><h6 id="随机从集合返回指定个数元素-srandmember"><a href="#随机从集合返回指定个数元素-srandmember" class="headerlink" title="随机从集合返回指定个数元素(srandmember)"></a>随机从集合返回指定个数元素(srandmember)</h6><p>srandmember key [count]</p>
<p>[count]是可选参数，如果不写默认为1:</p>
<pre><code>127.0.0.1:6379&gt; sadd myset a b c d
(integer) 3
127.0.0.1:6379&gt; srandmember myset 2
1) &quot;a&quot;
2) &quot;b&quot;
127.0.0.1:6379&gt; srandmember myset 
&quot;c&quot;
</code></pre><h6 id="从集合随机弹出元素-spop"><a href="#从集合随机弹出元素-spop" class="headerlink" title="从集合随机弹出元素(spop)"></a>从集合随机弹出元素(spop)</h6><p><code>spop</code>操作可以从集合中随机弹出一个元素：</p>
<pre><code>127.0.0.1:6379&gt; spop myset
&quot;a&quot;
</code></pre><h6 id="获取所有元素-smembers"><a href="#获取所有元素-smembers" class="headerlink" title="获取所有元素(smembers)"></a>获取所有元素(smembers)</h6><pre><code>127.0.0.1:6379&gt; smembers myset
1) &quot;d&quot;
2) &quot;b&quot;
3) &quot;c&quot;
</code></pre><h5 id="集合间操作"><a href="#集合间操作" class="headerlink" title="集合间操作"></a>集合间操作</h5><h6 id="求多个集合的交集-sinter"><a href="#求多个集合的交集-sinter" class="headerlink" title="求多个集合的交集(sinter)"></a>求多个集合的交集(sinter)</h6><pre><code>127.0.0.1:6379&gt; sadd myset1 a b c d
(integer) 4
127.0.0.1:6379&gt; sadd myset2 c d e f
(integer) 4
127.0.0.1:6379&gt; sinter myset1 myset2
1) &quot;d&quot;
2) &quot;c&quot;
</code></pre><h6 id="求多个集合的并集-sunion"><a href="#求多个集合的并集-sunion" class="headerlink" title="求多个集合的并集(sunion)"></a>求多个集合的并集(sunion)</h6><pre><code>127.0.0.1:6379&gt; sunion myset1 myset2
1) &quot;f&quot;
2) &quot;e&quot;
3) &quot;c&quot;
4) &quot;a&quot;
5) &quot;d&quot;
6) &quot;b&quot;
</code></pre><h6 id="求多个集合的差集-sdiff"><a href="#求多个集合的差集-sdiff" class="headerlink" title="求多个集合的差集(sdiff)"></a>求多个集合的差集(sdiff)</h6><pre><code>127.0.0.1:6379&gt; sdiff myset1 myset2
1) &quot;a&quot;
2) &quot;b&quot;
</code></pre><h6 id="将交集、并集、差集的结果保存-sinterstore、suionstore、sdiffstore"><a href="#将交集、并集、差集的结果保存-sinterstore、suionstore、sdiffstore" class="headerlink" title="将交集、并集、差集的结果保存(sinterstore、suionstore、sdiffstore)"></a>将交集、并集、差集的结果保存(sinterstore、suionstore、sdiffstore)</h6><p>sinterstore destination key [key …]<br>suionstore destination key [key …]<br>sdiffstore destination key [key …]</p>
<p>集合间的运算在元素较多的情况下会比较耗时，所以<code>Redis</code>提供了上面三个命令（原命令+store）将集合间交集、并集、差集的结果保存在<code>destination key</code>中。</p>
<pre><code>127.0.0.1:6379&gt; sinterstore myset myset1 myset2
(integer) 2
127.0.0.1:6379&gt; smembers myset
1) &quot;c&quot;
2) &quot;d&quot;
</code></pre><h4 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h4><p>集合类型的内部编码有两种：</p>
<ul>
<li><code>intset</code>（整数集合）：当集合中的元素都是整数且元素个数小于<code>set-maxintset-entries</code>配置（默认512个）时，<code>Redis</code>会选用<code>intset</code>来作为集合的内部实现，从而减少内存的使用。</li>
<li><code>hashtable</code>（哈希表）：当集合类型无法满足<code>intset</code>的条件时，<code>Redis</code>会使用<code>hashtable</code>作为集合的内部实现。</li>
</ul>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>集合类型比较典型的使用场景是标签（tag）。例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。</p>
<h3 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h3><p>它保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素可以排序。它给每个元素设置一个分数（score）作为排序的依据。有序集合中的元素不能重复，但是score可以重复。</p>
<h4 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h4><h5 id="集合内"><a href="#集合内" class="headerlink" title="集合内"></a>集合内</h5><h6 id="添加成员-zadd"><a href="#添加成员-zadd" class="headerlink" title="添加成员(zadd)"></a>添加成员(zadd)</h6><p>zadd key score member [score member …]</p>
<p>返回结果代表成功添加成员的个数：</p>
<pre><code>127.0.0.1:6379&gt; zadd user:ranking 251 tom
(integer) 1
127.0.0.1:6379&gt; zadd user:ranking 1 kris 91 mike 200 frank 220 tim 250 martin 
(integer) 5
</code></pre><p>有序集合相比集合提供了排序字段，但是也产生了代价，<code>zadd</code>的时间复杂度为O（log（n）），sadd的时间复杂度为O（1）</p>
<h6 id="计算成员个数-zcard"><a href="#计算成员个数-zcard" class="headerlink" title="计算成员个数(zcard)"></a>计算成员个数(zcard)</h6><p>和集合类型的<code>scard</code>命令一样，<code>zcard</code>的时间复杂度为O（1）。</p>
<pre><code>127.0.0.1:6379&gt; zcard user:ranking
(integer) 6
</code></pre><h6 id="计算某个成员的分数-zscore"><a href="#计算某个成员的分数-zscore" class="headerlink" title="计算某个成员的分数(zscore)"></a>计算某个成员的分数(zscore)</h6><p>如果成员不存在则返回nil：</p>
<pre><code>127.0.0.1:6379&gt; zscore user:ranking tom
&quot;251&quot;
127.0.0.1:6379&gt; zscore user:ranking no_exist_key
(nil)
</code></pre><h6 id="计算成员的排名-zrank、zrevrank"><a href="#计算成员的排名-zrank、zrevrank" class="headerlink" title="计算成员的排名(zrank、zrevrank)"></a>计算成员的排名(zrank、zrevrank)</h6><p>zrank key member<br>zrevrank key member</p>
<p><code>zrank</code>是从分数从低到高返回排名，<code>zrevrank</code>反之。（排名从0开始计算）</p>
<pre><code>127.0.0.1:6379&gt; zrank user:ranking tom
(integer) 5
127.0.0.1:6379&gt; zrevrank user:ranking tom
(integer) 0
</code></pre><h6 id="删除成员-zrem"><a href="#删除成员-zrem" class="headerlink" title="删除成员(zrem)"></a>删除成员(zrem)</h6><p>返回结果为成功删除的个数：</p>
<pre><code>127.0.0.1:6379&gt; zrem user:ranking mike
(integer) 1
</code></pre><h6 id="增加成员的分数-zincrby"><a href="#增加成员的分数-zincrby" class="headerlink" title="增加成员的分数(zincrby)"></a>增加成员的分数(zincrby)</h6><p>下面操作给tom增加了9分，分数变为了260分：</p>
<pre><code>127.0.0.1:6379&gt; zincrby user:ranking 9 tom
&quot;260&quot;
</code></pre><h6 id="返回指定排名范围的成员-zrange、zrevrange"><a href="#返回指定排名范围的成员-zrange、zrevrange" class="headerlink" title="返回指定排名范围的成员(zrange、zrevrange)"></a>返回指定排名范围的成员(zrange、zrevrange)</h6><p>zrange key start end [withscores]<br>zrevrange key start end [withscores]</p>
<p>有序集合是按照分值排名的，<code>zrange</code>是从低到高返回，<code>zrevrange</code>反之。如果加上<code>withscores</code>选项，同时会返回成员的分数：</p>
<pre><code>127.0.0.1:6379&gt; zrange user:ranking 0 2 withscores
1) &quot;kris&quot;
2) &quot;1&quot;
3) &quot;frank&quot;
4) &quot;200&quot;
5) &quot;tim&quot;
6) &quot;220&quot;
127.0.0.1:6379&gt; zrevrange user:ranking 0 2 withscores
1) &quot;tom&quot;
2) &quot;260&quot;
3) &quot;martin&quot;
4) &quot;250&quot;
5) &quot;tim&quot;
6) &quot;220&quot;
</code></pre><h6 id="返回指定分数范围的成员-zrangebyscore、zrevrangebyscore"><a href="#返回指定分数范围的成员-zrangebyscore、zrevrangebyscore" class="headerlink" title="返回指定分数范围的成员(zrangebyscore、zrevrangebyscore)"></a>返回指定分数范围的成员(zrangebyscore、zrevrangebyscore)</h6><p>zrangebyscore key min max [withscores] [limit offset count]<br>zrevrangebyscore key max min [withscores] [limit offset count]</p>
<p>其中<code>zrangebyscore</code>按照分数从低到高返回，<code>zrevrangebyscore</code>反之。<code>withscores</code>选项会同时返回每个成员的分数。<code>[limit offset count]</code>选项可以限制输出的起始位置和个数：</p>
<pre><code>127.0.0.1:6379&gt; zrangebyscore user:ranking 200 221 withscores
1) &quot;frank&quot;
2) &quot;200&quot;
3) &quot;tim&quot;
4) &quot;220&quot;
127.0.0.1:6379&gt; zrevrangebyscore user:ranking 221 200 withscores
1) &quot;tim&quot;
2) &quot;220&quot;
3) &quot;frank&quot;
4) &quot;200&quot;
</code></pre><p>同时<code>min</code>和<code>max</code>还支持开区间（小括号）和闭区间（中括号），<code>-inf</code>和<code>+inf</code>分别代表无限小和无限大：</p>
<pre><code>127.0.0.1:6379&gt; zrangebyscore user:ranking (200 +inf withscores
1) &quot;tim&quot;
2) &quot;220&quot;
3) &quot;martin&quot;
4) &quot;250&quot;
5) &quot;tom&quot;
6) &quot;260&quot;
</code></pre><h6 id="返回指定分数范围成员个数-zcount"><a href="#返回指定分数范围成员个数-zcount" class="headerlink" title="返回指定分数范围成员个数(zcount)"></a>返回指定分数范围成员个数(zcount)</h6><pre><code>127.0.0.1:6379&gt; zcount user:ranking 200 221
(integer) 2
</code></pre><h6 id="删除指定排名内的升序元素-zremrangebyrank"><a href="#删除指定排名内的升序元素-zremrangebyrank" class="headerlink" title="删除指定排名内的升序元素(zremrangebyrank)"></a>删除指定排名内的升序元素(zremrangebyrank)</h6><p>zremrangebyrank key start end</p>
<p>下面操作删除第start到第end名的成员：</p>
<pre><code>127.0.0.1:6379&gt; zremrangebyrank user:ranking 0 2
(integer) 3
</code></pre><h6 id="删除指定分数范围的成员-zremrangebyscore"><a href="#删除指定分数范围的成员-zremrangebyscore" class="headerlink" title="删除指定分数范围的成员(zremrangebyscore)"></a>删除指定分数范围的成员(zremrangebyscore)</h6><pre><code>127.0.0.1:6379&gt; zremrangebyscore user:ranking (250 +inf
(integer) 1
</code></pre><h4 id="内部编码-4"><a href="#内部编码-4" class="headerlink" title="内部编码"></a>内部编码</h4><ul>
<li><p><code>ziplist</code>（压缩列表）：当有序集合的元素个数小于<code>zset-max-ziplistentries</code>配置（默认128个），同时每个元素的值都小于<code>zset-max-ziplist-value</code>配置（默认64字节）时，<code>Redis</code>会用<code>ziplist</code>来作为有序集合的内部实现，<code>ziplist</code>可以有效减少内存的使用。</p>
</li>
<li><p><code>skiplist</code>（跳跃表）：当<code>ziplist</code>条件不满足时，有序集合会使用<code>skiplist</code>作为内部实现，因为此时<code>ziplist</code>的读写效率会下降。</p>
</li>
</ul>
<h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>有序集合比较典型的使用场景就是排行榜系统。例如视频网站需要对用户上传的视频做排行榜，榜单的维度可能是多个方面的：按照时间、按照播放数量、按照获得的赞数。</p>
<h3 id="键管理"><a href="#键管理" class="headerlink" title="键管理"></a>键管理</h3><h4 id="单个键管理"><a href="#单个键管理" class="headerlink" title="单个键管理"></a>单个键管理</h4><h5 id="键重命名-rename"><a href="#键重命名-rename" class="headerlink" title="键重命名(rename)"></a>键重命名(rename)</h5><pre><code>127.0.0.1:6379&gt; set python jedis
OK
127.0.0.1:6379&gt; set python java
OK
127.0.0.1:6379&gt; get python
&quot;java&quot;
127.0.0.1:6379&gt; get java
(nil)
</code></pre><p>如果在<code>rename</code>之前，键已经存在，那么它的值也将被覆盖:</p>
<pre><code>127.0.0.1:6379&gt; set a b
OK
127.0.0.1:6379&gt; set c d
OK
127.0.0.1:6379&gt; rename a c
OK
127.0.0.1:6379&gt; get a
(nil)
127.0.0.1:6379&gt; get c
&quot;b&quot;
</code></pre><p>为了防止被强行<code>rename</code>，<code>Redis</code>提供了<code>renamenx</code>命令，确保只有键不存在时候才被覆盖，返回结果是0代表没有完成重命名：</p>
<pre><code>127.0.0.1:6379&gt; set java jedis
OK
127.0.0.1:6379&gt; set python redis-py
OK
127.0.0.1:6379&gt; renamenx java python
(integer) 0
127.0.0.1:6379&gt; get java
&quot;jedis&quot;
127.0.0.1:6379&gt; get python
&quot;redis-py
</code></pre><p>由于重命名键期间会执行<code>del</code>命令删除旧的键，如果键对应的值比较大，会存在阻塞<code>Redis</code>的可能性。</p>
<h5 id="随机返回一个键-randomkey"><a href="#随机返回一个键-randomkey" class="headerlink" title="随机返回一个键(randomkey)"></a>随机返回一个键(randomkey)</h5><p><code>randomkey</code>命令会随机从数据库中挑选一个键：</p>
<pre><code>127.0.0.1:6379&gt; randomkey
&quot;hello&quot;
</code></pre><h5 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a>键过期</h5><p>除了<code>expire</code>、<code>ttl</code>命令以外，<code>Redis</code>还提供了<code>expireat</code>、<code>pexpire</code>、<code>pexpireat</code>、<code>pttl</code>、<code>persist</code>等一系列命令：</p>
<ul>
<li>expire key seconds：键在seconds秒后过期。</li>
<li>expireat key timestamp：键在秒级时间戳timestamp后过期。</li>
</ul>
<p><code>ttl</code>命令和<code>pttl</code>都可以查询键的剩余过期时间，但是<code>pttl</code>精度更高可以达到毫秒级别，有3种返回值：</p>
<ul>
<li>大于等于0的整数：键剩余的过期时间（<code>ttl</code>是秒，<code>pttl</code>是毫秒）。</li>
<li>-1：键没有设置过期时间。</li>
<li>-2：键不存在。</li>
</ul>
<p>除此之外，<code>Redis2.6</code>版本后提供了毫秒级的过期方案：</p>
<ul>
<li>pexpire key milliseconds：键在milliseconds毫秒后过期。</li>
<li>pexpireat key milliseconds-timestamp：键在毫秒级时间戳timestamp后过期。</li>
</ul>
<p>但无论是使用过期时间还是时间戳，秒级还是毫秒级，在<code>Redis</code>内部最终使用的都是<code>pexpireat</code>。</p>
<p>在使用<code>Redis</code>相关过期命令时，需要注意以下几点:</p>
<ol>
<li><p>如果expire key的键不存在，返回结果为0：</p>
<pre><code>127.0.0.1:6379&gt; expire not_exist_key 30
(integer) 0
</code></pre></li>
<li><p>如果过期时间为负值，键会立即被删除，犹如使用<code>del</code>命令一样：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; expire hello -2
(integer) 1
127.0.0.1:6379&gt; get hello
(nil)
</code></pre></li>
<li><p><code>persist</code>命令可以将键的过期时间清除：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; expire hello 50
(integer) 1
127.0.0.1:6379&gt; ttl hello
(integer) 48
127.0.0.1:6379&gt; persist hello
(integer) 1
127.0.0.1:6379&gt; ttl hello
(integer) -1
</code></pre></li>
<li><p>对于字符串类型键，执行<code>set</code>命令会去掉过期时间:</p>
<pre><code>127.0.0.1:6379&gt; ttl hello
(integer) 47
127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; ttl hello
(integer) -1
</code></pre></li>
<li><p><code>Redis</code>不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置。</p>
</li>
<li><p><code>setex</code>命令作为<code>set+expire</code>的组合，不但是原子执行，同时减少了一次网络通讯的时间。</p>
</li>
</ol>
<h5 id="迁移键"><a href="#迁移键" class="headerlink" title="迁移键"></a>迁移键</h5><p><code>Redis</code>发展历程中提供了<code>move</code>、<code>dump+restore</code>、<code>migrate</code>三组迁移键的方法，它们的实现方式以及使用的场景不太相同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用域</th>
<th style="text-align:center">原子性</th>
<th style="text-align:center">支持多个键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">move</td>
<td style="text-align:center">Redis实例内部</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">dump + restore</td>
<td style="text-align:center">Redis实例之间</td>
<td style="text-align:center">否</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">migrate</td>
<td style="text-align:center">Redis实例之间</td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<h4 id="遍历键"><a href="#遍历键" class="headerlink" title="遍历键"></a>遍历键</h4><h5 id="全量遍历键"><a href="#全量遍历键" class="headerlink" title="全量遍历键"></a>全量遍历键</h5><p>keys pattern</p>
<ul>
<li><code>*</code>代表匹配任意字符。</li>
<li><code>·</code>代表匹配一个字符。</li>
<li><code>[]</code>代表匹配部分字符，例如<code>[1，3]</code>代表匹配1，3，<code>[1-10]</code>代表匹配1到10的任意数字。</li>
<li><p><code>\x</code>用来做转义，例如要匹配星号、问号需要进行转义。</p>
<pre><code>127.0.0.1:6379&gt; mset hello world redis best jedis best hill high
OK
127.0.0.1:6379&gt; keys [j,r]edis
1) &quot;jedis&quot;
2) &quot;redis&quot;
127.0.0.1:6379&gt; keys hell*
1) &quot;hello&quot;
</code></pre></li>
</ul>
<p><code>keys</code>是一个很有帮助的命令，例如想删除所有以video字符串开头的键，可以执行如下操作：</p>
<pre><code>redis-cli keys video* | xargs redis-cli del
</code></pre><p>如果<code>Redis</code>包含了大量的键，执行<code>keys</code>命令很可能会造成<code>Redis</code>阻塞，所以一般建议不要在生产环境下使用<code>keys</code>命令。可以在以下三种情况使用：</p>
<ul>
<li>在一个不对外提供服务的<code>Redis</code>从节点上执行，这样不会阻塞到客户端的请求，但是会影响到主从复制。</li>
<li>如果确认键值总数确实比较少，可以执行该命令。</li>
<li>使用<code>scan</code>命令渐进式的遍历所有键，可以有效防止阻塞。</li>
</ul>
<h5 id="渐进式遍历"><a href="#渐进式遍历" class="headerlink" title="渐进式遍历"></a>渐进式遍历</h5><p>和<code>keys</code>命令执行时会遍历所有键不同，<code>scan</code>采用渐进式遍历的方式来解决<code>keys</code>命令可能带来的阻塞问题，每次<code>scan</code>命令的时间复杂度是O（1），但是要真正实现<code>keys</code>的功能，需要执行多次<code>scan</code>。</p>
<p>scan cursor [match pattern] [count number]</p>
<ul>
<li><code>cursor</code>是必需参数，实际上<code>cursor</code>是一个游标，第一次遍历从0开始，每次<code>scan</code>遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</li>
<li><code>match pattern</code>是可选参数，它的作用的是做模式的匹配，这点和<code>keys</code>的模式匹配很像。</li>
<li><code>count number</code>是可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</li>
</ul>
<p>现在要遍历所有的键，使用<code>scan</code>命令效果的操作如下。第一次执行<code>scan 0</code>，返回结果分为两个部分：第一个部分9就是下次<code>scan</code>需要的<code>cursor</code>，第二个部分是10个键：</p>
<pre><code>127.0.0.1:6379&gt; scan 0
1) &quot;9&quot;
2)  1) &quot;hill&quot;
    2) &quot;d&quot;
    3) &quot;mylist&quot;
    4) &quot;python&quot;
    5) &quot;key&quot;
    6) &quot;hello&quot;
    7) &quot;redis&quot;
    8) &quot;c&quot;
    9) &quot;user:1&quot;
10) &quot;listkey&quot;
</code></pre><p>继续执行<code>scan 9</code>得到结果<code>cursor</code>变为0，说明所有的键已经被遍历过了：</p>
<pre><code>127.0.0.1:6379&gt; scan 9
1) &quot;0&quot;
2) 1) &quot;b&quot;
2) &quot;java&quot;
3) &quot;jedis&quot;
</code></pre><p>除了<code>scan</code>以外，<code>Redis</code>提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如<code>hgetall</code>、<code>smembers</code>、<code>zrange</code>可能产生的阻塞问题，对应的命令分别是<code>hscan</code>、<code>sscan</code>、<code>zscan</code>，它们的用法和<code>scan</code>基本类似。</p>
<p>渐进式遍历可以有效的解决<code>keys</code>命令可能产生的阻塞问题，但是<code>scan</code>并非完美无瑕，如果在<code>scan</code>的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会碰到如下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说<code>scan</code>并不能保证完整的遍历出来所有的键，这些是我们在开发时需要考虑的。</p>
<h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><h5 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h5><p><code>Redis</code>用数字作为多个数据库的实现。<code>Redis</code>默认配置中是有16个数据库，但是0号数据库和15号数据库之间的数据没有任何关联，甚至可以存在相同的键：</p>
<pre><code>127.0.0.1:6379&gt; set hello world
OK
127.0.0.1:6379&gt; get hello
&quot;world&quot;
127.0.0.1:6379&gt; select 15
OK
127.0.0.1:6379[15]&gt; get hello 
(nil)
</code></pre><p>默认使用的就是0号数据库，当选择其他数据库时，会有<code>[index]</code>的前缀标识，其中<code>index</code>就是数据库的索引下标。</p>
<h5 id="flushdb-flushall"><a href="#flushdb-flushall" class="headerlink" title="flushdb/flushall"></a>flushdb/flushall</h5><p><code>flushdb/flushall</code>命令用于清除数据库，两者的区别的是<code>flushdb</code>只清除当前数据库，<code>flushall</code>会清除所有数据库。</p>
<pre><code>127.0.0.1:6379&gt; dbsize
(integer) 13
127.0.0.1:6379&gt; flushdb
OK
127.0.0.1:6379&gt; dbsize
(integer) 0
</code></pre><p><code>flushdb/flushall</code>命令可以非常方便的清理数据，但是也带来两个问题：</p>
<ul>
<li><code>flushdb/flushall</code>命令会将所有数据清除，一旦误操作后果不堪设想。</li>
<li>如果当前数据库键值数量比较多，<code>flushdb/flushall</code>存在阻塞<code>Redis</code>的可能性。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/03/web_framework/" rel="next" title="编写python Web框架">
                <i class="fa fa-chevron-left"></i> 编写python Web框架
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/07/redis_02/" rel="prev" title="Redis慢查询、Pipeline、事务与Lua、Bitmaps、发布订阅">
                Redis慢查询、Pipeline、事务与Lua、Bitmaps、发布订阅 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dva.jpg"
                alt="heqingliang" />
            
              <p class="site-author-name" itemprop="name">heqingliang</p>
              <p class="site-description motion-element" itemprop="description">曾梦想仗剑走天涯 看一看世界的繁华 年少的心总有些轻狂 如今你四海为家 曾让你心疼的姑娘 如今已悄然无踪影</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装并启动Redis"><span class="nav-number">1.</span> <span class="nav-text">安装并启动Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装Redis"><span class="nav-number">1.1.</span> <span class="nav-text">安装Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动Redis"><span class="nav-number">1.2.</span> <span class="nav-text">启动Redis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis命令行客户端"><span class="nav-number">1.3.</span> <span class="nav-text">Redis命令行客户端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止Redis服务"><span class="nav-number">1.4.</span> <span class="nav-text">停止Redis服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API的理解和使用"><span class="nav-number">2.</span> <span class="nav-text">API的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局命令"><span class="nav-number">2.1.</span> <span class="nav-text">全局命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查看所有键-key"><span class="nav-number">2.1.1.</span> <span class="nav-text">查看所有键(key*)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#键总数-dbsize"><span class="nav-number">2.1.2.</span> <span class="nav-text">键总数(dbsize)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#检查键是否存在-exists"><span class="nav-number">2.1.3.</span> <span class="nav-text">检查键是否存在(exists)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除键-del"><span class="nav-number">2.1.4.</span> <span class="nav-text">删除键(del)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#键过期-expire"><span class="nav-number">2.1.5.</span> <span class="nav-text">键过期(expire)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#键的数据结构类型-type"><span class="nav-number">2.1.6.</span> <span class="nav-text">键的数据结构类型(type)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构和内部编码"><span class="nav-number">2.2.</span> <span class="nav-text">数据结构和内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#单线程架构"><span class="nav-number">2.3.</span> <span class="nav-text">单线程架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么单线程还能这么快"><span class="nav-number">2.3.1.</span> <span class="nav-text">为什么单线程还能这么快</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">2.4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常用命令"><span class="nav-number">2.4.1.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#设置值-set"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">设置值(set)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获取值-get"><span class="nav-number">2.4.1.2.</span> <span class="nav-text">获取值(get)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#批量设置值-mset"><span class="nav-number">2.4.1.3.</span> <span class="nav-text">批量设置值(mset)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#批量获取值-mget"><span class="nav-number">2.4.1.4.</span> <span class="nav-text">批量获取值(mget)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计数-incr"><span class="nav-number">2.4.1.5.</span> <span class="nav-text">计数(incr)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不常用命令"><span class="nav-number">2.4.2.</span> <span class="nav-text">不常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#追加值-append"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">追加值(append)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#字符串长度-strlen"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">字符串长度(strlen)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#设置并返回原值-getset"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">设置并返回原值(getset)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#设置指定位置的字符-setrange"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">设置指定位置的字符(setrange)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获取部分字符串-getrange"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">获取部分字符串(getrange)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内部编码"><span class="nav-number">2.4.3.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#典型使用场景"><span class="nav-number">2.4.4.</span> <span class="nav-text">典型使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#缓存功能"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">缓存功能</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计数"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">计数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#共享Session"><span class="nav-number">2.4.4.3.</span> <span class="nav-text">共享Session</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#限速"><span class="nav-number">2.4.4.4.</span> <span class="nav-text">限速</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希"><span class="nav-number">3.</span> <span class="nav-text">哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令"><span class="nav-number">3.1.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设置值-hset"><span class="nav-number">3.1.1.</span> <span class="nav-text">设置值(hset)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取值-hget"><span class="nav-number">3.1.2.</span> <span class="nav-text">获取值(hget)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除field-hdel"><span class="nav-number">3.1.3.</span> <span class="nav-text">删除field(hdel)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#计算field个数-hlen"><span class="nav-number">3.1.4.</span> <span class="nav-text">计算field个数(hlen)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#批量设置或获取field-value-hmget、hmset"><span class="nav-number">3.1.5.</span> <span class="nav-text">批量设置或获取field-value(hmget、hmset)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断field是否存在-hexists"><span class="nav-number">3.1.6.</span> <span class="nav-text">判断field是否存在(hexists)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取所有field-hkeys"><span class="nav-number">3.1.7.</span> <span class="nav-text">获取所有field(hkeys)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取所有value-hvals"><span class="nav-number">3.1.8.</span> <span class="nav-text">获取所有value(hvals)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取所有的field-value-hgetall"><span class="nav-number">3.1.9.</span> <span class="nav-text">获取所有的field-value(hgetall)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hincrby-hincrbyfloat"><span class="nav-number">3.1.10.</span> <span class="nav-text">hincrby hincrbyfloat</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-1"><span class="nav-number">3.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景"><span class="nav-number">3.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表"><span class="nav-number">4.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-1"><span class="nav-number">4.1.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#添加操作"><span class="nav-number">4.1.1.</span> <span class="nav-text">添加操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#从右边插入元素-rpush"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">从右边插入元素(rpush)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#从左边插入元素-lpush"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">从左边插入元素(lpush)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#向某个元素前或者后插入元素-linsert"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">向某个元素前或者后插入元素(linsert)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查找"><span class="nav-number">4.1.2.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#获取指定范围内的元素列表-lrange"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">获取指定范围内的元素列表(lrange):</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获取列表指定索引下标的元素-lindex-："><span class="nav-number">4.1.2.2.</span> <span class="nav-text">获取列表指定索引下标的元素(lindex)：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获取列表长度-llen-："><span class="nav-number">4.1.2.3.</span> <span class="nav-text">获取列表长度(llen)：</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除"><span class="nav-number">4.1.3.</span> <span class="nav-text">删除</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#从列表左侧弹出元素-lpop"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">从列表左侧弹出元素(lpop)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#从列表右侧弹出-rpop"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">从列表右侧弹出(rpop)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除指定元素-lrem"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">删除指定元素(lrem)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#按照索引范围修剪列表-ltrim"><span class="nav-number">4.1.3.4.</span> <span class="nav-text">按照索引范围修剪列表(ltrim)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改"><span class="nav-number">4.1.4.</span> <span class="nav-text">修改</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#阻塞操作"><span class="nav-number">4.1.5.</span> <span class="nav-text">阻塞操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-2"><span class="nav-number">4.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-1"><span class="nav-number">4.3.</span> <span class="nav-text">使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#消息队列"><span class="nav-number">4.3.1.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#文章列表"><span class="nav-number">4.3.2.</span> <span class="nav-text">文章列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-2"><span class="nav-number">5.1.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#集合内操作"><span class="nav-number">5.1.1.</span> <span class="nav-text">集合内操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#添加元素-sadd"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">添加元素(sadd)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除元素-srem"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">删除元素(srem)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算元素个数-scard"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">计算元素个数(scard)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#判断元素是否在集合中-sismember"><span class="nav-number">5.1.1.4.</span> <span class="nav-text">判断元素是否在集合中(sismember)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#随机从集合返回指定个数元素-srandmember"><span class="nav-number">5.1.1.5.</span> <span class="nav-text">随机从集合返回指定个数元素(srandmember)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#从集合随机弹出元素-spop"><span class="nav-number">5.1.1.6.</span> <span class="nav-text">从集合随机弹出元素(spop)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#获取所有元素-smembers"><span class="nav-number">5.1.1.7.</span> <span class="nav-text">获取所有元素(smembers)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#集合间操作"><span class="nav-number">5.1.2.</span> <span class="nav-text">集合间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#求多个集合的交集-sinter"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">求多个集合的交集(sinter)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#求多个集合的并集-sunion"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">求多个集合的并集(sunion)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#求多个集合的差集-sdiff"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">求多个集合的差集(sdiff)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#将交集、并集、差集的结果保存-sinterstore、suionstore、sdiffstore"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">将交集、并集、差集的结果保存(sinterstore、suionstore、sdiffstore)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-3"><span class="nav-number">5.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-2"><span class="nav-number">5.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有序集合"><span class="nav-number">6.</span> <span class="nav-text">有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命令-3"><span class="nav-number">6.1.</span> <span class="nav-text">命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#集合内"><span class="nav-number">6.1.1.</span> <span class="nav-text">集合内</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#添加成员-zadd"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">添加成员(zadd)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算成员个数-zcard"><span class="nav-number">6.1.1.2.</span> <span class="nav-text">计算成员个数(zcard)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算某个成员的分数-zscore"><span class="nav-number">6.1.1.3.</span> <span class="nav-text">计算某个成员的分数(zscore)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#计算成员的排名-zrank、zrevrank"><span class="nav-number">6.1.1.4.</span> <span class="nav-text">计算成员的排名(zrank、zrevrank)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除成员-zrem"><span class="nav-number">6.1.1.5.</span> <span class="nav-text">删除成员(zrem)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#增加成员的分数-zincrby"><span class="nav-number">6.1.1.6.</span> <span class="nav-text">增加成员的分数(zincrby)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回指定排名范围的成员-zrange、zrevrange"><span class="nav-number">6.1.1.7.</span> <span class="nav-text">返回指定排名范围的成员(zrange、zrevrange)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回指定分数范围的成员-zrangebyscore、zrevrangebyscore"><span class="nav-number">6.1.1.8.</span> <span class="nav-text">返回指定分数范围的成员(zrangebyscore、zrevrangebyscore)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#返回指定分数范围成员个数-zcount"><span class="nav-number">6.1.1.9.</span> <span class="nav-text">返回指定分数范围成员个数(zcount)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除指定排名内的升序元素-zremrangebyrank"><span class="nav-number">6.1.1.10.</span> <span class="nav-text">删除指定排名内的升序元素(zremrangebyrank)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#删除指定分数范围的成员-zremrangebyscore"><span class="nav-number">6.1.1.11.</span> <span class="nav-text">删除指定分数范围的成员(zremrangebyscore)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部编码-4"><span class="nav-number">6.2.</span> <span class="nav-text">内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用场景-3"><span class="nav-number">6.3.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#键管理"><span class="nav-number">7.</span> <span class="nav-text">键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单个键管理"><span class="nav-number">7.1.</span> <span class="nav-text">单个键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#键重命名-rename"><span class="nav-number">7.1.1.</span> <span class="nav-text">键重命名(rename)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#随机返回一个键-randomkey"><span class="nav-number">7.1.2.</span> <span class="nav-text">随机返回一个键(randomkey)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#键过期"><span class="nav-number">7.1.3.</span> <span class="nav-text">键过期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#迁移键"><span class="nav-number">7.1.4.</span> <span class="nav-text">迁移键</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历键"><span class="nav-number">7.2.</span> <span class="nav-text">遍历键</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#全量遍历键"><span class="nav-number">7.2.1.</span> <span class="nav-text">全量遍历键</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#渐进式遍历"><span class="nav-number">7.2.2.</span> <span class="nav-text">渐进式遍历</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库管理"><span class="nav-number">7.3.</span> <span class="nav-text">数据库管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#切换数据库"><span class="nav-number">7.3.1.</span> <span class="nav-text">切换数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#flushdb-flushall"><span class="nav-number">7.3.2.</span> <span class="nav-text">flushdb/flushall</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">heqingliang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
