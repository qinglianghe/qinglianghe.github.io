<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Docker的网络实现了容器和容器外部、不同容器之间通信。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker的网络">
<meta property="og:url" content="http://yoursite.com/2018/10/11/docker_03/index.html">
<meta property="og:site_name" content="heqingliang&#39;s Blog">
<meta property="og:description" content="Docker的网络实现了容器和容器外部、不同容器之间通信。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/docker/topological_01.png">
<meta property="og:image" content="http://yoursite.com/images/docker/topological_02.png">
<meta property="og:image" content="http://yoursite.com/images/docker/topological_03.png">
<meta property="og:image" content="http://yoursite.com/images/docker/nginx.png">
<meta property="og:image" content="http://yoursite.com/images/docker/topological_04.png">
<meta property="og:updated_time" content="2018-11-14T23:23:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker的网络">
<meta name="twitter:description" content="Docker的网络实现了容器和容器外部、不同容器之间通信。">
<meta name="twitter:image" content="http://yoursite.com/images/docker/topological_01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/11/docker_03/"/>





  <title>Docker的网络 | heqingliang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">heqingliang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/11/docker_03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="heqingliang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dva.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="heqingliang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker的网络</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-11T00:00:00+08:00">
                2018-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>Docker的网络实现了容器和容器外部、不同容器之间通信。</p>
<a id="more"></a>
<h3 id="network-namespace"><a href="#network-namespace" class="headerlink" title="network namespace"></a>network namespace</h3><p>linux的network namespace是用来隔离网络设备, IP地址, 端口等，network namespace为命名空间中的所有进程提供了全新的网络堆栈。</p>
<h4 id="创建和删除-network-namespace"><a href="#创建和删除-network-namespace" class="headerlink" title="创建和删除 network namespace"></a>创建和删除 network namespace</h4><p>使用<code>ip netns add NAME</code>可以创建一个network namespace，如下是创建了两个network namespace，分别是test1、test2：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns add test1
[heql@ubuntu hello-world]$ sudo ip netns add test2
</code></pre><p>使用<code>ip netns delete NAME</code>即可删除一个network namespace。</p>
<h4 id="查看-network-namespace"><a href="#查看-network-namespace" class="headerlink" title="查看 network namespace"></a>查看 network namespace</h4><p>使用<code>ip netns list</code>可以查看network namespace：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns list
test2
test1
</code></pre><h4 id="查看-network-namespace的IP"><a href="#查看-network-namespace的IP" class="headerlink" title="查看 network namespace的IP"></a>查看 network namespace的IP</h4><pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip a
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre><p>从上面的可以看到lo的端口的状态是DOWN，如果想要lo的端口处于UP状态，可以使用如下命令：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip link set dev lo up
[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip link 
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</code></pre><h4 id="Veth"><a href="#Veth" class="headerlink" title="Veth"></a>Veth</h4><p>如果想要两个network namespace之间进行通信，需要使用Veth。</p>
<h5 id="创建veth"><a href="#创建veth" class="headerlink" title="创建veth"></a>创建veth</h5><pre><code>[heql@ubuntu hello-world]$ sudo ip link add veth-test1 type veth peer name veth-test2
</code></pre><p>添加成功后，执行<code>ip link</code>可以看到如下信息：</p>
<pre><code>[heql@ubuntu hello-world]$ ip link
30: veth-test2@veth-test1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 3a:ef:ae:66:3d:42 brd ff:ff:ff:ff:ff:ff
31: veth-test1@veth-test2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether ca:5d:6b:25:ce:02 brd ff:ff:ff:ff:ff:ff
</code></pre><h5 id="添加veth至network-namespace"><a href="#添加veth至network-namespace" class="headerlink" title="添加veth至network namespace"></a>添加veth至network namespace</h5><p>执行如下命令，可以把veth-test1添加到test1的network namespace：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip link set veth-test1 netns test1
[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
31: veth-test1@if30: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether ca:5d:6b:25:ce:02 brd ff:ff:ff:ff:ff:ff
</code></pre><p>同理可以把veth-test2添加到test2的network namespace：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test2 ip link
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
30: veth-test2@if31: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 3a:ef:ae:66:3d:42 brd ff:ff:ff:ff:ff:ff
</code></pre><h5 id="分配IP地址"><a href="#分配IP地址" class="headerlink" title="分配IP地址"></a>分配IP地址</h5><p>首先要启动veth端口：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip link set dev veth-test1 up 
[heql@ubuntu hello-world]$ sudo ip netns exec test2 ip link set dev veth-test2 up
</code></pre><p>分配IP地址：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip addr add 192.168.1.1/24 dev veth-test1 
[heql@ubuntu hello-world]$ sudo ip netns exec test2 ip addr add 192.168.1.2/24 dev veth-test2
[heql@ubuntu hello-world]$ 
[heql@ubuntu hello-world]$ sudo ip netns exec test1 ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
    valid_lft forever preferred_lft forever
31: veth-test1@if30: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether ca:5d:6b:25:ce:02 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.1/24 scope global veth-test1
    valid_lft forever preferred_lft forever
    inet6 fe80::c85d:6bff:fe25:ce02/64 scope link 
    valid_lft forever preferred_lft forever
[heql@ubuntu hello-world]$ sudo ip netns exec test2 ip a
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
30: veth-test2@if31: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 3a:ef:ae:66:3d:42 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.2/24 scope global veth-test2
    valid_lft forever preferred_lft forever
    inet6 fe80::38ef:aeff:fe66:3d42/64 scope link 
    valid_lft forever preferred_lft forever
</code></pre><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p>上面的配置成功后，network namespace test1和test2就可以正确通信了：</p>
<pre><code>[heql@ubuntu hello-world]$ sudo ip netns exec test1 ping 192.168.1.2
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.637 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.117 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.116 ms

[heql@ubuntu hello-world]$ sudo ip netns exec test2 ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=0.183 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=64 time=0.106 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=64 time=0.104 ms
^C
--- 192.168.1.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.104/0.131/0.183/0.036
</code></pre><h3 id="Docker的Bridge网络"><a href="#Docker的Bridge网络" class="headerlink" title="Docker的Bridge网络"></a>Docker的Bridge网络</h3><p>在bridge模式下：</p>
<ul>
<li>连在同一网桥上的容器可以相互通信，通过上面的veth实现。</li>
<li>容器也可以与外部通信，数据包从容器出来，由于容器是桥接到docker0上，所以数据包会发到docker0上，然后在通过NAT转换，实现对外通信。</li>
</ul>
<p>如下，创建一个的容器：</p>
<pre><code>[heql@ubuntu hello-world]$ docker run -d --name test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
[heql@ubuntu hello-world]$ docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
beb73a179c71        busybox             &quot;/bin/sh -c &apos;while t…&quot;   35 seconds ago      Up 32 seconds                           test1
</code></pre><p>通过下面的命令，可以看到test1的网络连接到bridge网络中：</p>
<pre><code>[heql@ubuntu hello-world]$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
be05ef2f2f1d        bridge              bridge              local
0609e6a3110a        host                host                local
effb6daa2ce0        none                null                local

[heql@ubuntu hello-world]$ docker network inspect be05ef2f2f1d
&quot;Containers&quot;: {
        &quot;beb73a179c71d64b7bb626f180374453062d1551dc4a2a989edbc81b6385ec64&quot;: {
            &quot;Name&quot;: &quot;test1&quot;,
            &quot;EndpointID&quot;: &quot;798b6bde6a1921729aab389efaa23dfdfc7ff14e8c851fc9c217ce43ea059b7d&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,
            &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        }
    }
</code></pre><p>使用<code>ip a</code>命令可以看到，如下两个接口，<code>docker0</code>、<code>veth54c9f49</code>：</p>
<pre><code>[heql@ubuntu hello-world]$ ip a
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:36:76:5f:42 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
    valid_lft forever preferred_lft forever
    inet6 fe80::42:36ff:fe76:5f42/64 scope link 
    valid_lft forever preferred_lft forever
33: veth54c9f49@if32: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether c2:50:52:9d:86:dc brd ff:ff:ff:ff:ff:ff
    inet6 fe80::c050:52ff:fe9d:86dc/64 scope link 
    valid_lft forever preferred_lft forever
</code></pre><p>进入test1容器，执行<code>ip -a</code>命令:</p>
<pre><code>[heql@ubuntu hello-world]$ docker exec -it test1 /bin/sh 
/ # ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
32: eth0@if33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
    valid_lft forever preferred_lft forever
</code></pre><p> 执行<code>brctl show</code>命令，可以看到，docker0上有一个<code>veth54c9f49</code>接口：</p>
<pre><code>[heql@ubuntu hello-world]$ brctl show
bridge name    bridge id        STP enabled    interfaces
docker0        8000.024236765f42    no        veth54c9f49
</code></pre><p>也就说，docker0上的<code>veth54c9f49</code>接口和容器test1里面的<code>eth0@if33</code>接口是一对veth，就像上面的network namespace test1和test2，从而实现了容器test1和docker0通信。形成了如下拓扑图：</p>
<p><img src="/images/docker/topological_01.png" alt="topological_01.png"></p>
<p>再创建一个容器test2：</p>
<pre><code>[heql@ubuntu hello-world]$ docker run -d --name test2 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
01ec580a6477d550f0245ca41b2e3f7c33896f9aeae5491d594ccfb511897676
[heql@ubuntu hello-world]$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
01ec580a6477        busybox             &quot;/bin/sh -c &apos;while t…&quot;   4 seconds ago       Up 3 seconds                            test2
beb73a179c71        busybox             &quot;/bin/sh -c &apos;while t…&quot;   39 minutes ago      Up 39 minutes                           test1
</code></pre><p>可以看到test2的网络连接到bridge网络中：</p>
<pre><code>[heql@ubuntu hello-world]$ docker network inspect be05ef2f2f1d
&quot;Containers&quot;: {
            &quot;01ec580a6477d550f0245ca41b2e3f7c33896f9aeae5491d594ccfb511897676&quot;: {
                &quot;Name&quot;: &quot;test2&quot;,
                &quot;EndpointID&quot;: &quot;c63309bec5f99de16b8542320f7e7fda5a85b5fd5e31aed6a23beba2d7831153&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;beb73a179c71d64b7bb626f180374453062d1551dc4a2a989edbc81b6385ec64&quot;: {
                &quot;Name&quot;: &quot;test1&quot;,
                &quot;EndpointID&quot;: &quot;798b6bde6a1921729aab389efaa23dfdfc7ff14e8c851fc9c217ce43ea059b7d&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
</code></pre><p>使用<code>brctl show</code>命令，可以看到，docker0上有两个接口，<code>veth54c9f49</code>、<code>veth04fe000</code>：</p>
<pre><code>[heql@ubuntu hello-world]$ brctl show
bridge name    bridge id        STP enabled    interfaces
docker0        8000.024236765f42    no        veth04fe000
                            veth54c9f49
</code></pre><p>形成了如下拓扑图：</p>
<p><img src="/images/docker/topological_02.png" alt="topological_02.png"></p>
<p>容器test1和test2，可以相互ping通：</p>
<pre><code>[heql@ubuntu hello-world]$ docker exec -it test1 /bin/sh 
/ # ping 172.17.0.3
PING 172.17.0.3 (172.17.0.3): 56 data bytes
64 bytes from 172.17.0.3: seq=0 ttl=64 time=1.878 ms
64 bytes from 172.17.0.3: seq=1 ttl=64 time=0.125 ms
64 bytes from 172.17.0.3: seq=2 ttl=64 time=0.194 ms

[heql@ubuntu hello-world]$ docker exec -it test2 /bin/sh
/ # ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.477 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.193 ms
64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.118 ms
</code></pre><p>在容器test1、test2中，对外网也是可以访问的，这是通过NAT转换实现的。</p>
<pre><code>[heql@ubuntu ~]$ docker exec -it test1 /bin/sh
/ # ping www.baidu.com
PING www.baidu.com (119.75.217.109): 56 data bytes
64 bytes from 119.75.217.109: seq=0 ttl=127 time=41.350 ms
64 bytes from 119.75.217.109: seq=1 ttl=127 time=43.619 ms
64 bytes from 119.75.217.109: seq=2 ttl=127 time=41.302 ms
</code></pre><p><img src="/images/docker/topological_03.png" alt="topological_03.png"></p>
<h4 id="容器间的LINK"><a href="#容器间的LINK" class="headerlink" title="容器间的LINK"></a>容器间的LINK</h4><p>容器间的LINK，提供了一种在不同的容器间可以通过容器的名字来通信的机制。例如有一个后台的程序，想要访问MySQL的容器的服务，就需要知道MySQL容器的IP地址和端口，但是容器的IP地址是不固定的，这是就可以使用容器间的LINK，使得后台的程序可以直接通过MySQL容器的名字和端口号，直接访问数据库。</p>
<p>启动test1容器：</p>
<pre><code>[heql@ubuntu ~]$ docker run -d --name=test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
</code></pre><p>启动test2容器，启动的时候指定link到test1容器中：</p>
<pre><code>[heql@ubuntu ~]$ docker run -d --name=test2 --link test1 busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
</code></pre><p>进入到test2容器中，直接使用容器test1的名字，就可以通信：</p>
<pre><code>[heql@ubuntu ~]$ docker exec -it test2 /bin/sh
/ # ping test1
PING test1 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.563 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.189 ms   
</code></pre><p>但是在容器test1中，不能直接使用容器test2的名字，进行通信，因为容器的link是有方向的：</p>
<pre><code>[heql@ubuntu ~]$ docker exec -it test1 /bin/sh
/ # ping test2
ping: bad address &apos;test2&apos;
</code></pre><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><pre><code>如下，创建了一个my-bridge的网络，driver使用的是bridge模式：

    ubuntu@docker-node1:~$ docker network create -d bridge my-bridge
ba700ffa1e8f645b2c96af09aa58eeddba973afe7356271828ebd56a6ce7b16a
ubuntu@docker-node1:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
d22bcab1e0eb        bridge              bridge              local
ff50d198b5dc        docker_gwbridge     bridge              local
65e22acf0beb        host                host                local
ba700ffa1e8f        my-bridge           bridge              local
c305a4b53c3b        none                null                local
</code></pre><p>在创建容器时，可以指定连接到c的网络：</p>
<pre><code>ubuntu@docker-node1:~$ docker run -d --name=test1 --network my-bridge busybox sh -c &quot;while true; do sleep 3600; done&quot;
f03bde21fd93473a9c918f83ca9df843836c73631d7c9b3b5c0ec9edf04da138
ubuntu@docker-node1:~$ docker run -d --name=test2 --network my-bridge busybox sh -c &quot;while true; do sleep 3600; done&quot;
7efcdd3343e0531aa0a108c7adb2cc18c8db4074bf4ce02c541ea24f91bf5144
</code></pre><p>可以看到容器test1、test2，已经连接到了my-bridge:</p>
<pre><code>ubuntu@docker-node1:~$ docker network inspect my-bridge
 &quot;Containers&quot;: {
        &quot;7efcdd3343e0531aa0a108c7adb2cc18c8db4074bf4ce02c541ea24f91bf5144&quot;: {
            &quot;Name&quot;: &quot;test2&quot;,
            &quot;EndpointID&quot;: &quot;e1e96d8ab020b65e92c9f1c7ed3177dbae0ab0e8af734860c84dff66a6d913f9&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:13:00:03&quot;,
            &quot;IPv4Address&quot;: &quot;172.19.0.3/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        },
        &quot;f03bde21fd93473a9c918f83ca9df843836c73631d7c9b3b5c0ec9edf04da138&quot;: {
            &quot;Name&quot;: &quot;test1&quot;,
            &quot;EndpointID&quot;: &quot;2badf2d43d973408bf9c8a6deb7cefc050ac527be4673f8b7a4f38319a3398a8&quot;,
            &quot;MacAddress&quot;: &quot;02:42:ac:13:00:02&quot;,
            &quot;IPv4Address&quot;: &quot;172.19.0.2/16&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        }
    },
</code></pre><p>执行命令，可以看到容器test1可以使用test2的IP进行通信：</p>
<pre><code>ubuntu@docker-node1:~$ docker exec test1 ping 172.19.0.3
PING 172.19.0.3 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.165 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.205 ms
64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.202 ms
</code></pre><p>直接使用test2的名字，也可以进行通信：</p>
<pre><code>ubuntu@docker-node1:~$ docker exec test1 ping test2
PING test2 (172.19.0.3): 56 data bytes
64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.167 ms
64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.214 ms
64 bytes from 172.19.0.3: seq=2 ttl=64 time=0.206 ms
</code></pre><p>反过来，在test2中使用容器test1的名字也是可以通信的：</p>
<pre><code>ubuntu@docker-node1:~$ docker exec test2 ping test1
PING test1 (172.19.0.2): 56 data bytes
64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.297 ms
64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.250 ms
64 bytes from 172.19.0.2: seq=2 ttl=64 time=0.277 ms
</code></pre><h4 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h4><p>在容器运行时，可以把容器内提供相应服务的端口，映射到本地的端口，如下，在运行nginx时，把nginx的容器的80端口映射到本地的8888端口：</p>
<pre><code>[heql@ubuntu ~]$ docker run -d -p 8888:80 nginx
a4830d511808145f312ee1548459046f89ecd348229f3d0ab18c9e473961cc00
[heql@ubuntu ~]$ docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
a4830d511808        nginx               &quot;nginx -g &apos;daemon of…&quot;   8 seconds ago       Up 7 seconds        0.0.0.0:8888-&gt;80/tcp   goofy_poitras
</code></pre><p>在本地的浏览器中，访问<code>127.0.0.1:8888</code>，可以看到如下的界面：</p>
<p><img src="/images/docker/nginx.png" alt="nginx.png"></p>
<h3 id="Docker的none网络和host网络"><a href="#Docker的none网络和host网络" class="headerlink" title="Docker的none网络和host网络"></a>Docker的none网络和host网络</h3><h4 id="none网络"><a href="#none网络" class="headerlink" title="none网络"></a>none网络</h4><p>none网络就是什么都没有的网络。挂在这个网络下的容器除了lo，没有其他任何网卡。容器run时，可以通过添加–network=none参数来指定该容器使用none网络。</p>
<p>none网络应用与隔离场景，一些对安全性要求高并且不需要联网的应用可以使用none网络。</p>
<p>如下，将容器test1连接到none网络，进入容器test1，可以看到只有lo接口：</p>
<pre><code>[heql@ubuntu ~]$ docker run -d --name=test1 --network=none busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
73ce8d01f47a5885ab303fb4c20ed0d4137d4466ec777a3a16e7d395aa6e3f11
[heql@ubuntu ~]$ docker exec -it test1 /bin/sh/ # ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
/ #
</code></pre><h4 id="host网络"><a href="#host网络" class="headerlink" title="host网络"></a>host网络</h4><p>连接到host网络的容器共享Docker宿主机的网络栈，即容器的网络配置与host宿主机完全一样。</p>
<p>直接使用Docker host的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择host网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题，Docker host上已经使用的端口就不能再用了。</p>
<p>如下，将容器test1连接到none网络，进入容器test1，可以看到容器test1的配置和主机时一样的：</p>
<pre><code>[heql@ubuntu ~]$ docker run -d --name=test1 --network=hos^Cusybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
[heql@ubuntu ~]$ docker run -d --name=test1 --network=host busybox /bin/sh -c &quot;while true; do sleep 3600; done&quot;
012810607ce59244b9a535f23297d34163e972328af6c263f731011c608d10e2
[heql@ubuntu ~]$ docker exec -it test1 /bin/sh/ # ip a
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
    valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:0c:29:78:54:21 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.135/24 brd 192.168.1.255 scope global eth0
    valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe78:5421/64 scope link 
    valid_lft forever preferred_lft forever
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue 
    link/ether 02:42:79:2a:5c:06 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
    valid_lft forever preferred_lft forever
    inet6 fe80::42:79ff:fe2a:5c06/64 scope link 
    valid_lft forever preferred_lft forever
14: br-50056a4d3184: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue 
    link/ether 02:42:7e:74:26:3f brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global br-50056a4d3184
    valid_lft forever preferred_lft forever
    inet6 fe80::42:7eff:fe74:263f/64 scope link 
    valid_lft forever preferred_lft forever
</code></pre><h3 id="多容器的部署"><a href="#多容器的部署" class="headerlink" title="多容器的部署"></a>多容器的部署</h3><p>有如下python程序，使用redis来记录每次访问web页面的次数，在部署时，可以把redis和应用程序部署在不同容器中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    flask demo</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'heqingliang'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">redis = Redis(host=os.environ.get(<span class="string">'REDIS_HOST'</span>, <span class="string">'127.0.0.1'</span>), port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    redis.incr(<span class="string">'hits'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;Hello Container, I have been seen %s times.&lt;/h1&gt;'</span> % (redis.get(<span class="string">'hits'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">5000</span>, debug=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行redis容器：</p>
<pre><code>[heql@ubuntu flask-demo]$ docker run -d --name=redis redis 37a3118b732b71d55a5ebc3caec5f28fd5332b53c61fef4383c8c811a70793b4
</code></pre><p> 如下是app.py程序的Dockerfile:</p>
<pre><code>FROM python
LABEL maintainer=&quot;heqingliang_gzus@163.com&quot;
RUN pip install flask redis
COPY app.py /app/
WORKDIR /app
EXPOSE 5000
CMD [&quot;python&quot;, &quot;app.py&quot;]
</code></pre><p>使用Dcokerfile构建image：</p>
<pre><code>[heql@ubuntu flask-demo]$ docker build -t heqingliang/flask-app .
</code></pre><p>运行容器时，使其link到redis容器，并通过环境变量REDIS_HOST设置redis容器的名字：</p>
<pre><code>[heql@ubuntu flask-demo]$ docker run -p 5000:5000 --link redis --name flask-redis -e REDIS_HOST=redis heqingliang/flask-app
</code></pre><p>访问<code>127.0.0.1:5000</code>，可以看到如下结果：</p>
<pre><code>[heql@ubuntu flask-demo]$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;1&apos; times.&lt;/h1&gt;
[heql@ubuntu flask-demo]$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;2&apos; times.&lt;/h1&gt;
[heql@ubuntu flask-demo]$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;3&apos; times.&lt;/h1&gt;
</code></pre><h3 id="Docker的overlay网络"><a href="#Docker的overlay网络" class="headerlink" title="Docker的overlay网络"></a>Docker的overlay网络</h3><p>overlay网络用于连接不同机器上的docker容器，允许不同机器上的容器相互通信。如上面的程序，如果把redis的容器和应用程序的容器分别部署在不同机器上，则需要使用overlay网络。如下面的拓扑图：</p>
<p><img src="/images/docker/topological_04.png" alt="topological_04.png"></p>
<p>要创建docker的overlay网络：</p>
<ul>
<li><p>首先要安装consul或者etcd、zookeeper的集群key-value存储服务。</p>
</li>
<li><p>组成集群的所有主机的主机名不允许重复，因为docker守护进程与consul/etcd/zookeeper通信时，以主机名相互区分</p>
</li>
</ul>
<h4 id="下载etcd"><a href="#下载etcd" class="headerlink" title="下载etcd"></a>下载etcd</h4><pre><code>ubuntu@docker-node2:~$ wget https://github.com/coreos/etcd/releases/download/v3.3.10/etcd-v3.3.10-linux-amd64.tar.gz
ubuntu@docker-node2:~$ tar xzf etcd-v3.3.10-linux-amd64.tar.gz
ubuntu@docker-node2:~$ cd etcd-v3.3.10-linux-arm64/
</code></pre><h4 id="启动etcd"><a href="#启动etcd" class="headerlink" title="启动etcd"></a>启动etcd</h4><p>在<code>192.168.33.10</code>机器上启动etcd：</p>
<pre><code>ubuntu@docker-node1:~/etcd-v3.3.10-linux-amd64$ nohup ./etcd --name docker-node1 --initial-advertise-peer-urls http://192.168.33.10:2380 \
--listen-peer-urls http://192.168.33.10:2380 \
--listen-client-urls http://192.168.33.10:2379,http://127.0.0.1:2379 \
--advertise-client-urls http://192.168.33.10:2379 \
--initial-cluster-token etcd-cluster \
--initial-cluster docker-node1=http://192.168.33.10:2380,docker-node2=http://192.168.33.11:2380 \
--initial-cluster-state new&amp;
</code></pre><p>在<code>192.168.33.11</code>机器上启动etcd：</p>
<pre><code>ubuntu@docker-node2:~/etcd-v3.3.10-linux-amd64$ nohup ./etcd --name docker-node2 --initial-advertise-peer-urls http://192.168.33.11:2380 \
--listen-peer-urls http://192.168.33.11:2380 \
--listen-client-urls http://192.168.33.11:2379,http://127.0.0.1:2379 \
--advertise-client-urls http://192.168.33.11:2379 \
--initial-cluster-token etcd-cluster \
--initial-cluster docker-node1=http://192.168.33.10:2380,docker-node2=http://192.168.33.11:2380 \
--initial-cluster-state new&amp;
</code></pre><ul>
<li><p><strong>listen-peer-urls：</strong> 用于节点与节点之间数据交换, 因此需要监听在其他节点可以访问的IP地址上</p>
</li>
<li><p><strong>listen-client-urls：</strong> 用户客户机访问etcd数据, 一般监听在本地, 如果需要集中管理, 可以监听在管理服务器可以访问的IP地址上</p>
</li>
<li><p><strong>advertise-client-urls：</strong> 在加入proxy节点后, 会使用该广播地址, 因此需要监听在一个proxy节点可以访问的IP地址上</p>
</li>
</ul>
<h4 id="查看etcd集群的状态"><a href="#查看etcd集群的状态" class="headerlink" title="查看etcd集群的状态"></a>查看etcd集群的状态</h4><pre><code>ubuntu@docker-node1:~/etcd-v3.3.10-linux-amd64$ ./etcdctl cluster-health
member e05c909863f53313 is healthy: got healthy result from http://192.168.33.10:2379
member f829e5361f1740cc is healthy: got healthy result from http://192.168.33.11:2379
cluster is healthy
</code></pre><h4 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a>重启docker</h4><p>重启docker，并指定cluster-store为etcd的地址：</p>
<p>在<code>192.168.33.10</code>执行如下命令：</p>
<pre><code>ubuntu@docker-node1:~/etcd-v3.3.10-linux-amd64$ sudo service docker stop
ubuntu@docker-node1:~/etcd-v3.3.10-linux-amd64$ sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.33.10:2379 --cluster-advertise=192.168.33.10:2375&amp;
</code></pre><p>在<code>192.168.33.11</code>执行如下命令：</p>
<pre><code>ubuntu@docker-node2:~/etcd-v3.3.10-linux-amd64$ sudo service docker stop
ubuntu@docker-node2:~/etcd-v3.3.10-linux-amd64$ sudo /usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock --cluster-store=etcd://192.168.33.11:2379 --cluster-advertise=192.168.33.11:2375&amp;
</code></pre><ul>
<li><p><strong>cluster-store：</strong> docker daemon所使用key value service的地址（本例中即etcd的服务地址）</p>
</li>
<li><p><strong>cluster-advertise</strong> 所使用网卡以及docker daemon端口信息</p>
</li>
<li><p><strong>-H：</strong> docker demon服务的地址和协议</p>
</li>
</ul>
<h4 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h4><p>在<code>192.168.33.10</code>创建overlay网络：</p>
<pre><code>ubuntu@docker-node1:~$ docker network create -d overlay demo
ubuntu@docker-node1:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
70d52172034e        bridge              bridge              local
88e42f2e0502        demo                overlay             global
ff50d198b5dc        docker_gwbridge     bridge              local
65e22acf0beb        host                host                local
c305a4b53c3b        none                null                local
</code></pre><p>在<code>192.168.33.11</code>也可以看到<code>192.168.33.10</code>创建的demo网络：</p>
<pre><code>ubuntu@docker-node2:~$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
eb0df6a88d4d        bridge              bridge              local
88e42f2e0502        demo                overlay             global
eac83f830fb1        docker_gwbridge     bridge              local
4dce7cd5aa57        host                host                local
83856f82e646        none                null                local
</code></pre><h4 id="容器间通信"><a href="#容器间通信" class="headerlink" title="容器间通信"></a>容器间通信</h4><p>在<code>192.168.33.10</code>启动如下容器：</p>
<pre><code>ubuntu@docker-node1:~$ docker run -d --name test1 --net demo busybox sh -c &quot;while true; do sleep 3600; done&quot;
</code></pre><p>在<code>192.168.33.11</code>启动如下容器（注意容器的名字不能和<code>192.168.33.10</code>名字一样）：</p>
<pre><code>ubuntu@docker-node2:~$ docker run -d --name test2 --net demo busybox sh -c &quot;while true; do sleep 3600; done&quot;
</code></pre><p>查看demo网络中信息，可以看到容器test1、test2已加入到demo网络中：</p>
<pre><code>ubuntu@docker-node1:~$ docker network inspect demo
 &quot;Containers&quot;: {
        &quot;6693b4f5d73d5b03d57aab98c19cf27de26b8e386740a438268f24d4e499bf1c&quot;: {
            &quot;Name&quot;: &quot;test1&quot;,
            &quot;EndpointID&quot;: &quot;19c78c97923a20e54c814c9e95d3d0956cfa08d21658e9e103a8c61faad5dea7&quot;,
            &quot;MacAddress&quot;: &quot;02:42:0a:00:00:02&quot;,
            &quot;IPv4Address&quot;: &quot;10.0.0.2/24&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        },
        &quot;ep-188d188dd00473acba7162fb524304ef6b7e07e4e71829e3d7dc624326c1eed5&quot;: {
            &quot;Name&quot;: &quot;test2&quot;,
            &quot;EndpointID&quot;: &quot;188d188dd00473acba7162fb524304ef6b7e07e4e71829e3d7dc624326c1eed5&quot;,
            &quot;MacAddress&quot;: &quot;02:42:0a:00:00:03&quot;,
            &quot;IPv4Address&quot;: &quot;10.0.0.3/24&quot;,
            &quot;IPv6Address&quot;: &quot;&quot;
        }
    },
</code></pre><p>在<code>192.168.33.10</code>执行如下命令，可以看到可以直接使用容器test2名字通信，可以使用test2的IP：</p>
<pre><code>ubuntu@docker-node1:~$ docker exec test1 ping test2
PING test2 (10.0.0.3): 56 data bytes
64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.581 ms
64 bytes from 10.0.0.3: seq=1 ttl=64 time=1.130 ms
64 bytes from 10.0.0.3: seq=2 ttl=64 time=1.371 ms
</code></pre><p>在<code>192.168.33.11</code>执行如下命令，可以看到可以直接使用容器test1名字通信，可以使用test1的IP：</p>
<pre><code>ubuntu@docker-node2:~$ docker exec test2 ping test1
PING test1 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: seq=0 ttl=64 time=0.566 ms
64 bytes from 10.0.0.2: seq=1 ttl=64 time=1.291 ms
64 bytes from 10.0.0.2: seq=2 ttl=64 time=1.100 ms
</code></pre><h4 id="在overlay网络中部署应用"><a href="#在overlay网络中部署应用" class="headerlink" title="在overlay网络中部署应用"></a>在overlay网络中部署应用</h4><p>如在上面多容器部署的例子，把redis和应用程序的容器部署在同一台机器，现在使用overlay网络把redis和应用程序部署在两台机器上，按照上面的方法，创建好overlay网络。</p>
<p>在<code>192.168.33.10</code>机器上启动redis：</p>
<pre><code>ubuntu@docker-node1:~$ docker run -d --name=redis --net demo redis
</code></pre><p>在<code>192.168.33.11</code>机器上启动应用程序：</p>
<pre><code>ubuntu@docker-node2:~$ docker run -d -p 5000:5000 --name flask-redis --net demo -e REDIS_HOST=redis heqingliang/flask-app
</code></pre><p>在<code>192.168.33.11</code>机器，访问<code>127.0.0.1:5000</code>，可以看到如下结果：</p>
<pre><code>ubuntu@docker-node2:~$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;1&apos; times.&lt;/h1&gt;
ubuntu@docker-node2:~$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;2&apos; times.&lt;/h1&gt;
ubuntu@docker-node2:~$ curl 127.0.0.1:5000
&lt;h1&gt;Hello Container, I have been seen b&apos;3&apos; times.&lt;/h1&gt;
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/09/dcoker_02/" rel="next" title="Dockerfile">
                <i class="fa fa-chevron-left"></i> Dockerfile
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/14/docker_04/" rel="prev" title="Docker的数据持久化、docker Compose">
                Docker的数据持久化、docker Compose <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dva.jpg"
                alt="heqingliang" />
            
              <p class="site-author-name" itemprop="name">heqingliang</p>
              <p class="site-description motion-element" itemprop="description">曾梦想仗剑走天涯 看一看世界的繁华 年少的心总有些轻狂 如今你四海为家 曾让你心疼的姑娘 如今已悄然无踪影</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#network-namespace"><span class="nav-number">1.</span> <span class="nav-text">network namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建和删除-network-namespace"><span class="nav-number">1.1.</span> <span class="nav-text">创建和删除 network namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-network-namespace"><span class="nav-number">1.2.</span> <span class="nav-text">查看 network namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看-network-namespace的IP"><span class="nav-number">1.3.</span> <span class="nav-text">查看 network namespace的IP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Veth"><span class="nav-number">1.4.</span> <span class="nav-text">Veth</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建veth"><span class="nav-number">1.4.1.</span> <span class="nav-text">创建veth</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#添加veth至network-namespace"><span class="nav-number">1.4.2.</span> <span class="nav-text">添加veth至network namespace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分配IP地址"><span class="nav-number">1.4.3.</span> <span class="nav-text">分配IP地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通信"><span class="nav-number">1.4.4.</span> <span class="nav-text">通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker的Bridge网络"><span class="nav-number">2.</span> <span class="nav-text">Docker的Bridge网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器间的LINK"><span class="nav-number">2.1.</span> <span class="nav-text">容器间的LINK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义网络"><span class="nav-number">2.2.</span> <span class="nav-text">自定义网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#端口映射"><span class="nav-number">2.3.</span> <span class="nav-text">端口映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker的none网络和host网络"><span class="nav-number">3.</span> <span class="nav-text">Docker的none网络和host网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#none网络"><span class="nav-number">3.1.</span> <span class="nav-text">none网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#host网络"><span class="nav-number">3.2.</span> <span class="nav-text">host网络</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多容器的部署"><span class="nav-number">4.</span> <span class="nav-text">多容器的部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker的overlay网络"><span class="nav-number">5.</span> <span class="nav-text">Docker的overlay网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#下载etcd"><span class="nav-number">5.1.</span> <span class="nav-text">下载etcd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动etcd"><span class="nav-number">5.2.</span> <span class="nav-text">启动etcd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看etcd集群的状态"><span class="nav-number">5.3.</span> <span class="nav-text">查看etcd集群的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重启docker"><span class="nav-number">5.4.</span> <span class="nav-text">重启docker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建overlay网络"><span class="nav-number">5.5.</span> <span class="nav-text">创建overlay网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器间通信"><span class="nav-number">5.6.</span> <span class="nav-text">容器间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在overlay网络中部署应用"><span class="nav-number">5.7.</span> <span class="nav-text">在overlay网络中部署应用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">heqingliang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
